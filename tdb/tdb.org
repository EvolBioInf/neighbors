#+begin_src latex
  \section{\ty{tdb}}
  The package \ty{tdb} provides code for constructing and navigating
  \ty{taxonDb} (Figure~\ref{fig:db}). Its outline has hooks for imports,
  types, methods, and functions.
  \bpa{tdb}{pa:tdb}
#+end_src
#+begin_src go <<tdb.go>>=
  // Package tdb constructs and queries the taxonomy database.
  package tdb

  import (
	  //<<Imports, Pa.~\ref{pa:tdb}>>
  )
  //<<Types, Pa.~\ref{pa:tdb}>>
  //<<Methods, Pa.~\ref{pa:tdb}>>
  //<<Functions, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  \epa
  The central type of \ty{tdb} is \ty{TaxonDB}, which wraps a database
  defined in the standard library.
#+end_src
#+begin_src go <<Types, Pa.~\ref{pa:tdb}>>=
  type TaxonomyDB struct {
	  db *sql.DB
  }
#+end_src
#+begin_src latex
  We import \ty{sql}. In addition, we import a driver for \ty{sqlite3},
  \ty{go-sqlite3}, using a blank import.
#+end_src
#+begin_src go <<Imports, Pa.~\ref{pa:tdb}>>=
  "database/sql"
  _ "github.com/mattn/go-sqlite3"
#+end_src
#+begin_src latex
  \subsection{\ty{NewTaxonomyDB}}
  The function \ty{NewTaxonomyDB} takes as parameters the names of the
  five input files and the name of the database. It opens these files,
  opens a new database, constructs the database, closes the files, and
  closes the database.
#+end_src
#+begin_src go <<Functions, Pa.~\ref{pa:tdb}>>=
  // NewTaxonomyDB takes as parameters the names of the five data files
  // and the database name, and constructs the database from them.
  func NewTaxonomyDB(nodes, names, prokaryotes,
	  eukaryotes, viruses, dbName string) {
	  //<<Open files, Pa.~\ref{pa:tdb}>>
	  //<<Open database, Pa.~\ref{pa:tdb}>>
	  //<<Construct database, Pa.~\ref{pa:tdb}>>
	  //<<Close database, Pa.~\ref{pa:tdb}>>
	  //<<Close files, Pa.~\ref{pa:tdb}>>
  }
#+end_src
#+begin_src latex
  We open the five input tables.
#+end_src
#+begin_src go <<Open files, Pa.~\ref{pa:tdb}>>=
  of := util.Open(nodes)
  af := util.Open(names)
  pf := util.Open(prokaryotes)
  ef := util.Open(eukaryotes)
  vf := util.Open(viruses)
#+end_src
#+begin_src latex
  We import \ty{util}.
#+end_src
#+begin_src go <<Imports, Pa.~\ref{pa:tdb}>>=
  "github.com/evolbioinf/neighbors/util"
#+end_src
#+begin_src latex
  Before opening the database, we check whether it already exists. If we
  cannot open the database, we abort.
#+end_src
#+begin_src go <<Open database, Pa.~\ref{pa:tdb}>>=
  //<<Does database exist? Pa.~\ref{pa:tdb}>>
  db, err := sql.Open("sqlite3", dbName)
  if err != nil { log.Fatal(err) }
#+end_src
#+begin_src latex
  We import \ty{log}.
#+end_src
#+begin_src go <<Imports, Pa.~\ref{pa:tdb}>>=
  "log"
#+end_src
#+begin_src latex
  If we are asked to build a new database on top of an existing one, the
  user has probably made a mistake, so we bow out.
#+end_src
#+begin_src go <<Does database exist? Pa.~\ref{pa:tdb}>>=
  _, err := os.Stat(dbName)
  if err == nil {
	  fmt.Fprintf(os.Stderr, "database %s already exists\n",
		  dbName)
	  os.Exit(1)
  }
#+end_src
#+begin_src latex
  We import \ty{os} and \ty{fmt}.
#+end_src
#+begin_src go <<Imports, Pa.~\ref{pa:tdb}>>=
  "os"
  "fmt"
#+end_src
#+begin_src latex
  To construct the database, we construct the input tables, and load
  their counterparts in the database.
#+end_src
#+begin_src go <<Construct database, Pa.~\ref{pa:tdb}>>=
  //<<Construct tables, Pa.~\ref{pa:tdb}>>
  //<<Load tables, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  As illustrated in Figure~\ref{fig:db}, we construct two tables,
  \ty{taxon} and \ty{genome}.
#+end_src
#+begin_src go <<Construct tables, Pa.~\ref{pa:tdb}>>=
  //<<Construct table \ty{taxon}, Pa.~\ref{pa:tdb}>>
  //<<Construct table \ty{genome}, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  Table \ty{taxon} has the attributes \ty{taxid}, \ty{parent}, and
  \ty{name}. Taxon-IDs are integers, names are text. Taxon-IDs also
  functions as primary key. As there are currently over two million
  taxa, we index all three attributes to ensure quick queries.
#+end_src
#+begin_src go <<Construct table \ty{taxon}, Pa.~\ref{pa:tdb}>>=
  sqlStmt := `create table taxon (
  taxid int, parent int, name text, primary key(taxid));
  create index taxon_taxid_idx on taxon(taxid);
  create index taxon_parent_idx on taxon(parent);
  create index taxon_name_idx on taxon(name);
  `
  if _, err := db.Exec(sqlStmt); err != nil {
	  log.Fatal(err)
  }
#+end_src
#+begin_src latex
  Table \ty{genome} has attributes \ty{taxid}, \ty{size}, and
  \ty{replicons}. To stress that every genome belongs to exactly one
  taxon, we declare \ty{taxid} as foreign key into \ty{taxon}. We also
  index the taxon-ID.
#+end_src
#+begin_src go <<Construct table \ty{genome}, Pa.~\ref{pa:tdb}>>=
  sqlStmt = `create table genome (
  taxid int, size real, replicons text,
  foreign key(taxid) references taxon(taxid));
  create index genome_taxid_idx on genome(taxid);
  `
  if _, err := db.Exec(sqlStmt); err != nil {
	  log.Fatal(err)
  }
#+end_src
#+begin_src latex
  Since \ty{genome} has a foreign key referring to \ty{taxon}, we load
  \ty{taxon} before \ty{genome}.
#+end_src
#+begin_src go <<Load tables, Pa.~\ref{pa:tdb}>>=
  //<<Load table \ty{taxon}, Pa.~\ref{pa:tdb}>>
  //<<Load table \ty{genome}, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex 
  To load \ty{taxon}, we simulate a join of \ty{nodes.dmp} and
  \ty{names.dmp} on taxon-ID. For this we create the type \ty{taxon}
  with the same three fields as the three attributes in
  Figure~\ref{fig:db}.
#+end_src
#+begin_src go <<Types, Pa.~\ref{pa:tdb}>>=
  type taxon struct {
	  taxid, parent int
	  name string
  }
#+end_src
#+begin_src latex
  We read the taxa into a map and insert them into the table \ty{taxon}.
#+end_src
#+begin_src go <<Load table \ty{taxon}, Pa.~\ref{pa:tdb}>>=
  taxa := make(map[int]*taxon)
  //<<Read taxa, Pa.~\ref{pa:tdb}>>
  //<<Insert taxa, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  To read the taxa, we first parse the nodes file, then the names file.
#+end_src
#+begin_src go <<Read taxa, Pa.~\ref{pa:tdb}>>=
  //<<Parse nodes file, Pa.~\ref{pa:tdb}>>
  //<<Parse names file, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  We traverse the nodes file using a scanner. The first column contains
  the taxon-ID, the second the parent's ID. Columns are delimited by
  \verb+\t|\t+ and we convert the strings denoting IDs to integers
  before storing them.
#+end_src
#+begin_src go <<Parse nodes file, Pa.~\ref{pa:tdb}>>=
  scanner := bufio.NewScanner(of)
  for scanner.Scan() {
	  row := scanner.Text()
	  fields := strings.SplitN(row, "\t|\t", 3)
	  t := new(taxon)
	  t.taxid, err = strconv.Atoi(fields[0])
	  if err != nil { log.Fatal(err) }
	  t.parent, err = strconv.Atoi(fields[1])
	  if err != nil { log.Fatal(err) }
	  taxa[t.taxid] = t
  }
#+end_src
#+begin_src latex
  We import \ty{bufio}, \ty{strings}, and \ty{strconv}.
#+end_src
#+begin_src go <<Imports, Pa.~\ref{pa:tdb}>>=
  "bufio"
  "strings"
  "strconv"
#+end_src
#+begin_src latex
  We are done with the nodes file and close it.
#+end_src
#+begin_src go <<Close files, Pa.~\ref{pa:tdb}>>=
  of.Close()
#+end_src
#+begin_src latex
  The names file contains the taxon-ID in the first column and the name
  in the second. Now, there are several kinds of names, scientific,
  common, and more. We store the scientific names. To parse the file, we
  again use a scanner and split the columns at \verb+\t|\t+.
#+end_src
#+begin_src go <<Parse names file, Pa.~\ref{pa:tdb}>>=
  scanner = bufio.NewScanner(af)
  for scanner.Scan() {
	  row := scanner.Text()
	  fields := strings.Split(row, "\t|\t")
	  id, err := strconv.Atoi(fields[0])
	  if err != nil { log.Fatal(err) }
	  if fields[3][:3] == "sci" {
		  taxa[id].name = fields[1]
	  }
  }
#+end_src
#+begin_src latex
  We are done with the names file and close it.
#+end_src
#+begin_src go <<Close files, Pa.~\ref{pa:tdb}>>=
  af.Close()
#+end_src
#+begin_src latex
  Having read the taxa from the input files, we insert them in the
  \ty{taxon} table. We do this with a transaction, which takes a
  statement and prepares it, before we insert the individual rows into
  \ty{taxon}.
#+end_src
#+begin_src go <<Insert taxa, Pa.~\ref{pa:tdb}>>=
  tx, err := db.Begin()
  if err != nil { log.Fatal(err) }
  sqlStmt = "insert into taxon(taxid, parent, name) " +
	  "values(?, ?, ?)"
  stmt, err := tx.Prepare(sqlStmt)
  if err != nil { log.Fatal(err) }
  //<<Insert rows into table \ty{taxon}, Pa.~\ref{pa:tdb}>>
  tx.Commit()
  stmt.Close()
#+end_src
#+begin_src latex
  Each entry in the \ty{taxa} map corresponds to a row in the table.
#+end_src
#+begin_src go <<Insert rows into table \ty{taxon}, Pa.~\ref{pa:tdb}>>=
  for _, v := range taxa {
	  _, err = stmt.Exec(v.taxid, v.parent, v.name)
	  if err != nil { log.Fatal(err) }
  }
#+end_src
#+begin_src latex
  The next table to load is \ty{genome}. So we also read the genomes
  from input and insert them.
#+end_src
#+begin_src go <<Load table \ty{genome}, Pa.~\ref{pa:tdb}>>=
  //<<Read genomes, Pa.~\ref{pa:tdb}>>
  //<<Insert genomes, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  We read each genome into a struct that holds the three attributes
  shown in Figure~\ref{fig:db}, \ty{taxid}, \ty{replicons}, and
  \ty{size}.
#+end_src
#+begin_src go <<Types, Pa.~\ref{pa:tdb}>>=
  type genome struct {
	  taxid int
	  replicons string
	  size float64
  }
#+end_src
#+begin_src latex
  We save genomes in a slice and read them from the three files that
  correspond to three deep divisions of life, prokaryotes, eukaryotes,
  and viruses.
#+end_src
#+begin_src go <<Read genomes, Pa.~\ref{pa:tdb}>>=
  var genomes []genome
  //<<Read prokaryote genomes, Pa.~\ref{pa:tdb}>>
  //<<Read eukaryote genomes, Pa.~\ref{pa:tdb}>>
  //<<Read virus genomes, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  In the prokaryote genomes file, we skip the header, split the columns
  at tabs, generate the genomes and save them.
#+end_src
#+begin_src go <<Read prokaryote genomes, Pa.~\ref{pa:tdb}>>=
  fn := pf.Name()
  scanner = bufio.NewScanner(pf)
  var gen genome
  for scanner.Scan() {
	  row := scanner.Text()
	  if row[0] == '#' { continue }
	  fields := strings.Split(row, "\t")
	  //<<Generate a genome, Pa.~\ref{pa:tdb}>>
	  genomes = append(genomes, gen)
  }
#+end_src
#+begin_src latex
  In an individual row, the second column contains the taxon-ID, the
  seventh the size in Mb, and the nineth the replicons. Unfortunately,
  it is possible that no genome size is given, in which case we set it
  to -1. It is also possible that the row is incomplete, in which case
  we skip it and send a warning.
#+end_src
#+begin_src go <<Generate a genome, Pa.~\ref{pa:tdb}>>=
  if len(fields) < 9 {
	  fmt.Fprintf(os.Stderr,
		  "skipping truncated line in %q\n", fn)
	  continue
  }
  gen.taxid, err = strconv.Atoi(fields[1])
  if err != nil { log.Fatal(err) }
  gen.size, err = strconv.ParseFloat(fields[6], 64)
  if err != nil { gen.size = -1.0 }
  gen.replicons = fields[8]
#+end_src
#+begin_src latex
  We close the prokaryote genomes file.
#+end_src
#+begin_src go <<Close files, Pa.~\ref{pa:tdb}>>=
  pf.Close()
#+end_src
#+begin_src latex
  Similarly, we read the file for the eukaryote genomes, which has the
  same structure as that of the prokaryotes.
#+end_src
#+begin_src go <<Read eukaryote genomes, Pa.~\ref{pa:tdb}>>=
  fn = ef.Name()
  scanner = bufio.NewScanner(ef)
  for scanner.Scan() {
	  row := scanner.Text()
	  if row[0] == '#' { continue }
	  fields := strings.Split(row, "\t")
	  //<<Generate a genome, Pa.~\ref{pa:tdb}>>
	  genomes = append(genomes, gen)
  }
#+end_src
#+begin_src latex
  We close the eukaryote genomes file.
#+end_src
#+begin_src go <<Close files, Pa.~\ref{pa:tdb}>>=
  ef.Close()
#+end_src
#+begin_src latex
  We scan the file of viral genomes.
#+end_src
#+begin_src go <<Read virus genomes, Pa.~\ref{pa:tdb}>>=
  fn = vf.Name()
  scanner = bufio.NewScanner(vf)
  for scanner.Scan() {
	  row := scanner.Text()
	  if row[0] == '#' { continue }
	  fields := strings.Split(row, "\t")
	  //<<Generate a viral genome, Pa.~\ref{pa:tdb}>>
	  genomes = append(genomes, gen)
  }
#+end_src
#+begin_src latex
  The file describing the genomes of viruses has a slightly different
  structure from that of prokaryotes and eukaryotes. Replicons are now
  in the tenth column, and genome size is given in kb. We convert that
  to Mb to have all genome lengths on the same scale. Again, if a line
  is incomplete, we skip it with message.
#+end_src
#+begin_src go <<Generate a viral genome, Pa.~\ref{pa:tdb}>>=
  if len(fields) < 10 {
	  fmt.Fprintf(os.Stderr,
		  "skipping truncated line in %q", fn)
	  continue
  }
  gen.taxid, err = strconv.Atoi(fields[1])
  if err != nil { log.Fatal(err) }
  gen.size, err = strconv.ParseFloat(fields[6], 64)
  if err != nil { gen.size = -1.0 }
  if gen.size > 0 { gen.size /= 1000.0 }
  gen.replicons = fields[9]
#+end_src
#+begin_src latex
  We close the virus genomes file.
#+end_src
#+begin_src go <<Close files, Pa.~\ref{pa:tdb}>>=
  vf.Close()
#+end_src
#+begin_src latex
  To insert the genomes into the \ty{genomes} table, we use a
  transaction like we did for the \ty{taxon} table.
#+end_src
#+begin_src go <<Insert genomes, Pa.~\ref{pa:tdb}>>=
  tx, err = db.Begin()
  if err != nil { log.Fatal(err) }
  sqlStmt = "insert into genome(taxid, replicons, size) " +
	  "values(?, ?, ?)"
  stmt, err = tx.Prepare(sqlStmt)
  if err != nil { log.Fatal(err) }
  //<<Insert rows into table \ty{genome}, Pa.~\ref{pa:tdb}>>
  tx.Commit()
  stmt.Close()
#+end_src
#+begin_src latex
  We insert each entry in the \ty{genomes} slice into table \ty{genome}.
#+end_src
#+begin_src go <<Insert rows into table \ty{genome}, Pa.~\ref{pa:tdb}>>=
  for _, g := range genomes {
	  _, err = stmt.Exec(g.taxid, g.replicons, g.size)
	  if err != nil { log.Fatal(err) }
  }
#+end_src
#+begin_src latex
  The database is constructed, so we close it.
#+end_src
#+begin_src go <<Close database, Pa.~\ref{pa:tdb}>>=
  db.Close()
#+end_src
#+begin_src latex
  \subsection{\ty{OpenTaxonomyDB}}
  The function \ty{OpenTaxonomyDB} opens an existing taxonomy database
  and returns a pointer to it.
#+end_src
#+begin_src go <<Functions, Pa.~\ref{pa:tdb}>>=
  // OpenTaxonomyDB opens an existing taxonomy database and returns a
  // pointer to it.
  func OpenTaxonomyDB(name string) *TaxonomyDB {
	  db := new(TaxonomyDB)
	  var err error
	  db.db, err = sql.Open("sqlite3", name)
	  if err != nil { log.Fatal(err) }
	  return db
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Close}}
  The method \ty{Close} closes a taxonomy database.
#+end_src
#+begin_src go <<Methods, Pa.~\ref{pa:tdb}>>=
  // Close closes the taxonomy database.
  func (t *TaxonomyDB) Close() {
	  t.db.Close()
  }
#+end_src
#+begin_src latex
  \subsection{\ty{NewTaxonomy}}
  The method \ty{NewTaxonomy} reads the taxonomy of a set of taxa from
  the database. If the supplied set of taxa is empty or nil, the
  complete taxonomy is returned. The taxa from which the taxonomic tree
  is to be built are stored in two maps, \ty{tax} and
  \ty{parents}. \ty{tax} maps a taxon-ID, which is an integer, to a
  taxon node. \ty{parents} maps a taxon's ID to that of its parent. From
  these two maps we then construct the tree.
#+end_src
#+begin_src go <<Methods, Pa.~\ref{pa:tdb}>>=
  // NewTaxonomy reads the taxonomy from the database.
  func (t *TaxonomyDB) NewTaxonomy(taxa []int) tax.Taxonomy {
	  ta := make(map[int]*tax.Node)
	  parents := make(map[int]int)
	  if taxa == nil || len(taxa) == 0 {
		  //<<Parse taxon table, Pa.~\ref{pa:tdb}>>
	  } else {
		  //<<Parse taxon slice, Pa.~\ref{pa:tdb}>>
	  }
	  //<<Construct tree, Pa.~\ref{pa:tdb}>>
	  return ta
  }
#+end_src
#+begin_src latex
  We import \ty{tax}.
#+end_src
#+begin_src go <<Imports, Pa.~\ref{pa:tdb}>>=
  "github.com/evolbioinf/neighbors/tax"
#+end_src
#+begin_src latex
  We query the \ty{taxon} table, store the taxa, and check for errors at the
  end.
#+end_src
#+begin_src go <<Parse taxon table, Pa.~\ref{pa:tdb}>>=
  //<<Query taxon table, Pa.~\ref{pa:tdb}>>
  //<<Store taxa, Pa.~\ref{pa:tdb}>>
  //<<Check for errors in taxon query, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  Our query of the \ty{taxon} table returns the full table.
#+end_src
#+begin_src go <<Query taxon table, Pa.~\ref{pa:tdb}>>=
  q := "select name, taxid, parent from taxon"
  rows, err := t.db.Query(q)
  if err != nil {
	  log.Fatalf("couldn't run %q", q)
  }
  defer rows.Close()
#+end_src
#+begin_src latex
  We iterate over the rows of the query and store each row as a
  taxon. We also store its parent.
#+end_src
#+begin_src go <<Store taxa, Pa.~\ref{pa:tdb}>>=
  var taxid, parent int
  var name string
  for rows.Next() {
	  err = rows.Scan(&name, &taxid, &parent)
	  if err != nil {
		  log.Fatal(err)
	  }
	  v := &(tax.Node{ID: taxid, Name: name})
	  ta[taxid] = v
	  parents[taxid] = parent
  }
#+end_src
#+begin_src latex
  The query table might be left in an error state, in which case we
  bail.
#+end_src
#+begin_src go <<Check for errors in taxon query, Pa.~\ref{pa:tdb}>>=
  err = rows.Err()
  if err != nil {
	  log.Fatal(err)
  }
#+end_src
#+begin_src latex
  Instead of the full taxon table, we now work from a slice of taxa. We
  do this in two steps. First we construct a path of nodes from the
  first taxon to the root of the taxonomy. We call this chain of nodes
  the ``root path''. Then we construct nodes for the remaining taxa and
  attach them to the root path.
#+end_src
#+begin_src go <<Parse taxon slice, Pa.~\ref{pa:tdb}>>=
  //<<Construct root path, Pa.~\ref{pa:tdb}>>
  taxa = taxa[1:]
  for _, tid := range taxa {
	  v := &(tax.Node{ID: tid, Name: t.Name(tid)})
	  ta[tid] = v
	  p := parents[tid]
	  for p == 0 {
		  //<<Attach taxon to root path, Pa.~\ref{pa:tdb}>>
	  }
  }
#+end_src
#+begin_src latex
  The root path extends from the first taxon to the root of the
  taxonomy. The root is the only node whose ID is identical to that of
  its parent.
#+end_src
#+begin_src go <<Construct root path, Pa.~\ref{pa:tdb}>>=
  tid := taxa[0]
  for tid != parents[tid] {
	  v := &(tax.Node{ID: tid, Name: t.Name(tid)})
	  ta[tid] = v
	  parents[tid] = t.Parent(tid)
	  tid = parents[tid]
  }
#+end_src
#+begin_src latex
  We add the current node on our way to the root path and move to its
  parent.
#+end_src
#+begin_src go <<Attach taxon to root path, Pa.~\ref{pa:tdb}>>=
  v = &(tax.Node{ID: tid, Name: t.Name(tid)})
  ta[tid] = v
  p = t.Parent(tid)
  parents[tid] = p
  tid = p
  p = parents[tid]
#+end_src
#+begin_src latex
  The tree topology is now implicit in the map of parents. To construct
  an explicit tree from this, we iterate over all taxa and access the
  corresponding child/parent pairs. As the parent of the root is the
  root itself, we might be dealing with two roots at this
  point. Treating them like an ordinary child/parent pair would lead to
  the construction of a loop, so we check for this before setting the
  links between parent and child.
#+end_src
#+begin_src go <<Construct tree, Pa.~\ref{pa:tdb}>>=
  for k, v := range parents {
	  if k != v {
		  child := ta[k]
		  parent := ta[v]
		  //<<Set links between parent and child, Pa.~\ref{pa:tdb}>>
	  }
  }
#+end_src
#+begin_src latex
  We set the child's parent link and add it to its parent's list of
  children.
#+end_src
#+begin_src go <<Set links between parent and child, Pa.~\ref{pa:tdb}>>=
  child.Parent = parent
  if parent.Child == nil {
	  parent.Child = child
	  parent.Child.LastSib = child
  } else {
	  c := parent.Child
	  c.LastSib.Sib = child
	  c.LastSib = child
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Replicons}}
  The method \ty{Replicons} takes as parameter a taxon-ID and returns a
  slice of genome accessions.

  We query for replicons and then store them in the string slice we
  return.
#+end_src
#+begin_src go <<Methods, Pa.~\ref{pa:tdb}>>=
  func (t *TaxonomyDB) Replicons(tid int) []string {
	  var reps []string
	  //<<Query for replicions, Pa.~\ref{pa:tdb}>>
	  //<<Store replicons, Pa.~\ref{pa:tdb}>>
	  return reps
  }
#+end_src
#+begin_src latex
  We generate the query and execute it, which returns a set of table
  rows. The rows are later closed again.
#+end_src
#+begin_src go <<Query for replicions, Pa.~\ref{pa:tdb}>>=
  tmpl := "select replicons from genome where taxid=%d " +
	  "and replicons <> '-'"
  q := fmt.Sprintf(tmpl, tid)
  rows, err := t.db.Query(q)
  if err != nil {
	  log.Fatal(err)
  }
  defer rows.Close()
#+end_src
#+begin_src latex
  We import \ty{fmt}.
#+end_src
#+begin_src go <<Imports, Pa.~\ref{pa:tdb}>>=
  "fmt"
#+end_src
#+begin_src latex
  We append each replicon to our slice of replicons.
#+end_src
#+begin_src go <<Store replicons, Pa.~\ref{pa:tdb}>>=
  s := ""
  for rows.Next() {
	  err := rows.Scan(&s)
	  if err != nil {
		  log.Fatal(err)
	  }
	  reps = append(reps, s)
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Name}}
  The method \ty{Name} takes as argument a taxon ID and returns the
  taxon's name. We construct the query, execute it, and extract the
  name.
#+end_src
#+begin_src go <<Methods, Pa.~\ref{pa:tdb}>>=
  // Name returns a taxon's name.
  func (t *TaxonomyDB) Name(taxon int) string {
	  n := ""
	  //<<Construct name query, Pa.~\ref{pa:tdb}>>
	  //<<Execute name query, Pa.~\ref{pa:tdb}>>
	  //<<Extract name, Pa.~\ref{pa:tdb}>>
	  return n
  }
#+end_src
#+begin_src latex
  We construct the query from a string template.
#+end_src
#+begin_src go <<Construct name query, Pa.~\ref{pa:tdb}>>=
  tmpl := "select name from taxon where taxid=%d"
  q := fmt.Sprintf(tmpl, taxon)
#+end_src
#+begin_src latex
  We execute the query, which might throw an error. We also close the
  results table once we're done with it.
#+end_src
#+begin_src go <<Execute name query, Pa.~\ref{pa:tdb}>>=
  rows, err := t.db.Query(q)
  if err != nil {
	  log.Fatal(err)
  }
  defer rows.Close()
#+end_src
#+begin_src latex
  Our results table contains only the requested single name. We scan
  this and catch potential errors.
#+end_src
#+begin_src go <<Extract name, Pa.~\ref{pa:tdb}>>=
  rows.Next()
  err = rows.Scan(&n)
  if err != nil {
	  log.Fatal(err)
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Parent}}
  The method \ty{Parent} takes as argument a taxon ID and returns the
  taxon ID of its parent. We construct the query, execute it, and
  extract the parent.
#+end_src
#+begin_src go <<Methods, Pa.~\ref{pa:tdb}>>=
  // Parent returns a taxon's parent.
  func (t *TaxonomyDB) Parent(c int) int {
	  p := 0
	  //<<Construct parent query, Pa.~\ref{pa:tdb}>>
	  //<<Execute parent query, Pa.~\ref{pa:tdb}>>
	  //<<Extract parent, Pa.~\ref{pa:tdb}>>
	  return p
  }
#+end_src
#+begin_src latex
  We construct the parent query from a string template.
#+end_src
#+begin_src go <<Construct parent query, Pa.~\ref{pa:tdb}>>=
  tmpl := "select parent from taxon where taxid=%d"
  q := fmt.Sprintf(tmpl, c)
#+end_src
#+begin_src latex
  We execute the query to get the results table. Query execution might
  throw an error, which we catch. We also make sure the results table is
  eventually closed again.
#+end_src
#+begin_src go <<Execute parent query, Pa.~\ref{pa:tdb}>>=
  rows, err := t.db.Query(q)
  if err != nil {
	  log.Fatal(err)
  }
  defer rows.Close()
#+end_src
#+begin_src latex
  Our results table contains at most one row with one entry, the
  parent. We extract this and catch possible errors.
#+end_src
#+begin_src go <<Extract parent, Pa.~\ref{pa:tdb}>>=
  rows.Next()
  err = rows.Scan(&p)
  if err != nil {
	  log.Fatal(err)
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Children}}
  The method \ty{Children} takes as argument a taxon ID and returns its
  children. We construct the children query, execute it, and extract the
  children. The children are stored in an integer slice, which we
  construct at the start of the method and return at the end.
#+end_src
#+begin_src go <<Methods, Pa.~\ref{pa:tdb}>>=
  // Children returns a taxon's children.
  func (t *TaxonomyDB) Children(p int) []int {
	  c := make([]int, 0)
	  //<<Construct children query, Pa.~\ref{pa:tdb}>>
	  //<<Execute children query, Pa.~\ref{pa:tdb}>>
	  //<<Extract children, Pa.~\ref{pa:tdb}>>
	  return c
  }
#+end_src
#+begin_src latex
  Like the parent query, we construct the children query from a string
  template.
#+end_src
#+begin_src go <<Construct children query, Pa.~\ref{pa:tdb}>>=
  tmpl := "select taxid from taxon where parent=%d"
  q := fmt.Sprintf(tmpl, p)
#+end_src
#+begin_src latex
  We execute the children query to get the results table, catch errors,
  and eventually close the results table again.
#+end_src
#+begin_src go <<Execute children query, Pa.~\ref{pa:tdb}>>=
  rows, err := t.db.Query(q)
  if err != nil {
	  log.Fatal(err)
  }
  defer rows.Close()
#+end_src
#+begin_src latex
  We copy the children into the slice we've prepared for this purpose.
#+end_src
#+begin_src go <<Extract children, Pa.~\ref{pa:tdb}>>=
  x := 0
  for rows.Next() {
	  err = rows.Scan(&x)
	  if err != nil {
		  log.Fatal(err)
	  }
	  c = append(c, x)
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Subtree}}
  The method \ty{Subtree} returns all taxa in a subtree, including its
  root. It does this by calling the private function \ty{traverseSubtree}.
#+end_src
#+begin_src go <<Methods, Pa.~\ref{pa:tdb}>>=
  // Subtree returns the taxa in the subtree rooted on the given taxon.
  func (t *TaxonomyDB) Subtree(r int) []int {
	  taxa := make([]int, 0)
	  taxa = traverseSubtree(t, r, taxa)
	  return taxa
  }
#+end_src
#+begin_src latex
  \ty{traverseSubtree} is a recursive function.
#+end_src
#+begin_src go <<Functions, Pa.~\ref{pa:tdb}>>=
  func traverseSubtree(t *TaxonomyDB, r int, taxa []int) []int {
	  taxa = append(taxa, r)
	  ch := t.Children(r)
	  for _, c := range ch {
		  taxa = traverseSubtree(t, c, taxa)
	  }
	  return taxa
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Taxids}}
  Given a taxon name, \ty{Taxids} returns the corresponding
  taxon-IDs. We construct and execute the query for taxon-IDS, extract
  the IDs, and return them.
#+end_src
#+begin_src go <<Methods, Pa.~\ref{pa:tdb}>>=
  // Taxids matches the name of a taxon and returns the corresponding
  // taxon-IDs.
  func (t *TaxonomyDB) Taxids(name string) []int {
	  taxids := make([]int, 0)
	  //<<Construct taxids query, Pa.~\ref{pa:tdb}>>
	  //<<Execute taxids query, Pa.~\ref{pa:tdb}>>
	  //<<Extract taxids, Pa.~\ref{pa:tdb}>>
	  return taxids
  }
#+end_src
#+begin_src latex
  We construct the query for taxon-IDs.
#+end_src
#+begin_src go <<Construct taxids query, Pa.~\ref{pa:tdb}>>=
  q := "select taxid from taxon where name like '%s'"
  q = fmt.Sprintf(q, name)
#+end_src
#+begin_src latex
  We execute the query for taxon-IDs and catch potential errors. We also
  make sure the result table is eventually closed again.
#+end_src
#+begin_src go <<Execute taxids query, Pa.~\ref{pa:tdb}>>=
  rows , err := t.db.Query(q)
  if err != nil {
	  log.Fatal(err)
  }
  defer rows.Close()
#+end_src
#+begin_src latex
  We extract and store the taxon-IDs.
#+end_src
#+begin_src go <<Extract taxids, Pa.~\ref{pa:tdb}>>=
  taxid := 0
  for rows.Next() {
	  err = rows.Scan(&taxid)
	  if err != nil {
		  log.Fatal(err)
	  }
	  taxids = append(taxids, taxid)
  }
#+end_src
#+begin_src latex
  \subsection{Testing}
  The outline of our code for testing \ty{tdb} has a hook for the
  testing logic.
#+end_src
#+begin_src go <<tdb_test.go>>=
  package tdb

  import (
	  "testing"
  )

  func TestTdb(t *testing.T) {
	  //<<Testing, Pa.~\ref{pa:tdb}>>
  }
#+end_src
#+begin_src latex
  We test the function \ty{NewTaxonomyDB}, and the methods
  \ty{NewTaxonomy}, \ty{Replicons}, \ty{Name}, \ty{Parent},
  \ty{Children}, \ty{Subtree}, and \ty{Taxids}.
#+end_src
#+begin_src go <<Testing, Pa.~\ref{pa:tdb}>>=
  //<<Test \ty{NewTaxonomyDB}, Pa.~\ref{pa:tdb}>>
  //<<Test \ty{NewTaxonomy}, Pa.~\ref{pa:tdb}>>
  //<<Test \ty{Replicons}, Pa.~\ref{pa:tdb}>>
  //<<Test \ty{Name}, Pa.~\ref{pa:tdb}>>
  //<<Test \ty{Parent}, Pa.~\ref{pa:tdb}>>
  //<<Test \ty{Children}, Pa.~\ref{pa:tdb}>>
  //<<Test \ty{Subtree}, Pa.~\ref{pa:tdb}>>
  //<<Test \ty{Taxids}, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  We build a small database, \ty{taxSmall.db}.
#+end_src
#+begin_src go <<Test \ty{NewTaxonomyDB}, Pa.~\ref{pa:tdb}>>=
  p := "../data/"
  no := p + "nodesTest.dmp"
  na := p + "namesTest.dmp"
  pr := p + "prokaryotes.txt"
  eu := p + "eukaryotes.txt"
  vi := p + "viruses.txt"
  d1 := p + "taxSmall.db"
  NewTaxonomyDB(no, na, pr, eu, vi, d1)
#+end_src
#+begin_src latex
  We extract the full taxonomy from the small database and check it has
  9 entries.
#+end_src
#+begin_src go <<Test \ty{NewTaxonomyDB}, Pa.~\ref{pa:tdb}>>=
  taxdb := OpenTaxonomyDB(d1)
  ta := taxdb.NewTaxonomy(nil)
  if len(ta) != 9 {
	  t.Errorf("get %d rows, want 9", len(ta))
  }
#+end_src
#+begin_src latex
  We open a complete taxonomy database, get the full taxonomy from it,
  and the name for entry 9606, \emph{Homo sapiens}.
#+end_src
#+begin_src go <<Test \ty{NewTaxonomy}, Pa.~\ref{pa:tdb}>>=
  d2 := p + "tax.db"
  taxdb = OpenTaxonomyDB(d2)
  ta = taxdb.NewTaxonomy(nil)
  want := "Homo sapiens"
  get := ta[9606].Name
  if get != want {
	  t.Errorf("get: %q; want: %q", get, want)
  }
#+end_src
#+begin_src latex
  We get a partial taxonomy for \emph{Homo sapiens} (9606) and
  \emph{Gorilla gorilla gorilla} (9595). Its most recent common ancestor
  is \emph{Hominidae} (207598).
#+end_src
#+begin_src go <<Test \ty{NewTaxonomy}, Pa.~\ref{pa:tdb}>>=
  w := 207598
  taxa := []int{9606, 9595}
  tp := taxdb.NewTaxonomy(taxa)
  g := tp.MRCA(taxa)
  if g != w {
	  t.Errorf("get MRCA %d; want %d", g, w)
  }
#+end_src
#+begin_src latex
  We also check that the MRCA found in the complete taxonomy is the same
  as that found in the partial taxonomy.
#+end_src
#+begin_src go <<Test \ty{NewTaxonomy}, Pa.~\ref{pa:tdb}>>=
  g = ta.MRCA(taxa)
  if g != w {
	  t.Errorf("get MRCA %d; want %d", g, w)
  }
#+end_src
#+begin_src latex 
  We submit three taxon-IDs to the method \ty{Replicons} and print out the
  result.
#+end_src
#+begin_src go <<Test \ty{Replicons}, Pa.~\ref{pa:tdb}>>=
  tid := 866775
  reps := taxdb.Replicons(tid)
  get = reps[0]
  want = "chromosome:NC_015278.1/CP002512.1"
  if get != want {
	  t.Errorf("get: %q; want: %q", get, want)
  }
#+end_src
#+begin_src latex
  We look up the name of taxon, 9606, \emph{Homo sapiens}.
#+end_src
#+begin_src go <<Test \ty{Name}, Pa.~\ref{pa:tdb}>>=
  tid = 9606
  want = "Homo sapiens"
  get = taxdb.Name(tid)
  if get != want {
	  t.Errorf("get: %q; want: %q", get, want)
  }
#+end_src
#+begin_src latex
  The parent of \emph{Homo sapiens} is \emph{Homo} with taxon-ID
  9605.
#+end_src
#+begin_src go <<Test \ty{Parent}, Pa.~\ref{pa:tdb}>>=
  w = 9605
  g = taxdb.Parent(tid)
  if g != w {
	  t.Errorf("get parent: %d; want: %d", g, w)
  }
#+end_src
#+begin_src latex
  \emph{Homo sapiens} (9606) has two children.
#+end_src
#+begin_src go <<Test \ty{Children}, Pa.~\ref{pa:tdb}>>=
  w = 2
  g = len(taxdb.Children(tid))
  if g != w {
	  t.Errorf("get %d children; want %d", g, w)
  }
#+end_src
#+begin_src latex
  The \emph{Hominidae} subtree contains 25 nodes.
#+end_src
#+begin_src go <<Test \ty{Subtree}, Pa.~\ref{pa:tdb}>>=
  tid = 207598
  w = 25
  taxa = taxdb.Subtree(tid)
  g = len(taxa)
  if g != w {
	  t.Errorf("get %d nodes in subtree; want %d", g, w)
  }
#+end_src
#+begin_src latex
  To test \ty{Taxids}, we get the ten taxa whose names contain
  \emph{homo sapiens}. Notice the lower-case ``h'' in \emph{homo}, which
  SQL matches to the upper-case ``H'' in the actual names.
#+end_src
#+begin_src go <<Test \ty{Taxids}, Pa.~\ref{pa:tdb}>>=
  w = 10
  taxa = taxdb.Taxids("%homo sapiens%")
  g = len(taxa)
  if g != w {
	  t.Errorf("get %d taxa for homo sapiens; want %d", g, w)
  }
#+end_src

