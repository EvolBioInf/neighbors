#+begin_src latex
  \section{\ty{tdb}}
  ! Package tdb constructs and queries the taxonomy database.

  Figure~\ref{fig:db} shows the ER diagram of the taxonomy database,
  which consists of three tables, \ty{taxon}, \ty{genome}, and
  \ty{genome\_count}. The outline of \ty{tdb} has hooks for imports,
  types, variables, methods, and functions. It also has a hook for a
  special kind of package variable, the templates for SQL queries.
  \bpa{tdb}{pa:tdb}
#+end_src
#+begin_src go <<tdb.go>>=
  package tdb

  import (
	  //<<Imports, Pa. \ref{pa:tdb}>>
  )
  //<<Types, Pa. \ref{pa:tdb}>>
  //<<Variables, Pa. \ref{pa:tdb}>>
  //<<Methods, Pa. \ref{pa:tdb}>>
  //<<Functions, Pa. \ref{pa:tdb}>>
  //<<Query templates, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  \epa The package \ty{tdb} has two central types: \ty{TaxonDB} wraps
  the relational database shown in Figure~\ref{fig:db} and \ty{Taxonomy}
  is the taxonomic tree.
#+end_src
#+begin_src go <<Types, Pa. \ref{pa:tdb}>>=
  type TaxonomyDB struct {
	  db *sql.DB
  }
#+end_src
#+begin_src latex
  We import \ty{sql}. In addition, we import a driver for \ty{sqlite3},
  \ty{go-sqlite3}, using a blank import.
#+end_src
#+begin_src go <<Imports, Pa. \ref{pa:tdb}>>=
  "database/sql"
  _ "github.com/mattn/go-sqlite3"
#+end_src
#+begin_src latex
  \subsection{\ty{NewTaxonomyDB}}
  ! The function \ty{NewTaxonomyDB} takes as parameters the names of the
  ! five input files from which we construct the database, and the name of
  ! the database. It opens these files, opens a new database, and
  ! constructs the database.
#+end_src
#+begin_src go <<Functions, Pa. \ref{pa:tdb}>>=
  func NewTaxonomyDB(nodes, names, merged,
	  genbank, refseq, dbName string) {
	  //<<Open files, Pa. \ref{pa:tdb}>>
	  //<<Open database, Pa. \ref{pa:tdb}>>
	  //<<Construct database, Pa. \ref{pa:tdb}>>
  }
#+end_src
#+begin_src latex
  We open the five input tables and defer closing them again.
#+end_src
#+begin_src go <<Open files, Pa. \ref{pa:tdb}>>=
  of := util.Open(nodes)
  defer of.Close()
  af := util.Open(names)
  defer af.Close()
  mf := util.Open(merged)
  defer mf.Close()
  gf := util.Open(genbank)
  defer gf.Close()
  rf := util.Open(refseq)
  defer rf.Close()
#+end_src
#+begin_src latex
  We import \ty{util}.
#+end_src
#+begin_src go <<Imports, Pa. \ref{pa:tdb}>>=
  "github.com/evolbioinf/neighbors/util"
#+end_src
#+begin_src latex
  Before opening the database, we check whether it already exists. Then
  we open---and hence construct---it from scratch. If that fails, we
  abort. We also make sure the database is eventually closed again.
#+end_src
#+begin_src go <<Open database, Pa. \ref{pa:tdb}>>=
  //<<Does database exist? Pa. \ref{pa:tdb}>>
  db, err := sql.Open("sqlite3", dbName)
  util.Check(err)
  defer db.Close()
#+end_src
#+begin_src latex
  If we are asked to build a new database on top of an existing one, the
  user has probably made a mistake, so we bow out.
#+end_src
#+begin_src go <<Does database exist? Pa. \ref{pa:tdb}>>=
  _, err := os.Stat(dbName)
  if err == nil {
	  fmt.Fprintf(os.Stderr, "database %s already exists\n",
		  dbName)
	  os.Exit(1)
  }
#+end_src
#+begin_src latex
  We import \ty{fmt}.
#+end_src
#+begin_src go <<Imports, Pa. \ref{pa:tdb}>>=
  "os"
  "fmt"
#+end_src
#+begin_src latex
  To construct the database, we construct the tables and load them.
#+end_src
#+begin_src go <<Construct database, Pa. \ref{pa:tdb}>>=
  //<<Construct tables, Pa. \ref{pa:tdb}>>
  //<<Load tables, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_export latex
As illustrated in Figure~\ref{fig:db}, we construct three tables,
\ty{taxon}, \ty{genome}, and \ty{genome\_count}.
#+end_export
#+begin_src go <<Construct tables, Pa. \ref{pa:tdb}>>=
  //<<Construct table \ty{taxon}, Pa. \ref{pa:tdb}>>
  //<<Construct table \ty{genome}, Pa. \ref{pa:tdb}>>
  //<<Construct table \ty{genome\_count}, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  Table \ty{taxon} has the five attributes \ty{taxid}, \ty{parent},
  \ty{name}, \ty{rank}, and score. Taxon-IDs are integers, names are
  text, scores are floats. \ty{taxid} is also the primary key. As there
  are currently 2.7 million taxa, and this number is bound to grow, we
  ensure that queries are quick by using indexes. The primary key,
  \ty{taxid}, is automatically indexed but we explicitly construct an
  index for \ty{parent} and \ty{score}. We might be tempted to also
  index the remaining three attributes, \ty{name}, \ty{common\_name},
  and \ty{rank}. However, these are text and \ty{sqlite} does not make
  use of indexes on text columns. You can check this on an existing
  database by prefacing a query with \ty{explain query plan}. So we just
  index \ty{parent}.
#+end_src
#+begin_src go <<Construct table \ty{taxon}, Pa. \ref{pa:tdb}>>=
  sqlStmt := `create table taxon (
    taxid int primary key,
    parent int,
    name text,
    common_name text,
    rank text,
    score float);
  create index taxon_parent_idx on taxon(parent);
  create index taxon_score_idx on taxon(score);`
  _, err = db.Exec(sqlStmt)
  util.Check(err)
#+end_src
#+begin_src latex
  Table \ty{genome} has the four attributes \ty{taxid}, \ty{size},
  \ty{accession}, and an assembly \ty{level}. An accession is unique, so
  it also serves as primary key. The size is given in bp, but we store
  it as Mb, so its type is float. To stress that every genome belongs to
  exactly one taxon, we declare \ty{taxid} as foreign key into
  \ty{taxon}. We also index the numerical attributes \ty{taxid} and
  \ty{size}.
#+end_src
#+begin_src go <<Construct table \ty{genome}, Pa. \ref{pa:tdb}>>=
  sqlStmt = `create table genome (
    taxid int,
    size real, 
    accession text primary key,
    level text,
    foreign key(taxid) references taxon(taxid));
  create index genome_taxid_idx on genome(taxid);
  create index genome_size_idx on genome(size);`
  _, err = db.Exec(sqlStmt)
  util.Check(err)
#+end_src
#+begin_export latex
Table \ty{genome\_count} has four attributes, \ty{taxid} and
\ty{level}, which together form the primary key, and the two counts
\ty{raw} and \ty{recursive}. The attribute \ty{taxid} is also a
foreign key into table \ty{taxon}. We index the raw and recursive
genome counts.
#+end_export
#+begin_src go <<Construct table \ty{genome\_count}, Pa. \ref{pa:tdb}>>=
  sqlStmt = `create table genome_count (
    taxid int,
    level text,
    raw int,
    recursive int,
    primary key(taxid, level),
    foreign key(taxid) references taxon(taxid));
  create index genome_count_raw_idx on genome_count(raw);
  create index genome_count_recursive_idx on genome_count(recursive);`
  _, err = db.Exec(sqlStmt)
  util.Check(err)
#+end_src
#+begin_src latex
  Since \ty{genome} and \ty{genome\_count} have a foreign key referring
  to \ty{taxon}, we load \ty{taxon} first. There's a snag here,
  though. The score of a taxon can only be determined once the genome
  counts have been determined. These in turn depend on the entries in
  table \ty{genome}. Hence we load \ty{genomes} after \ty{taxon},
  followed by \ty{genome\_count}. Then we return to table \ty{taxon} and
  load the score.
#+end_src
#+begin_src go <<Load tables, Pa. \ref{pa:tdb}>>=
  //<<Load table \ty{taxon}, Pa. \ref{pa:tdb}>>
  //<<Load table \ty{genome}, Pa. \ref{pa:tdb}>>
  //<<Load table \ty{genome\_count}, Pa. \ref{pa:tdb}>>
  //<<Enter score in table \ty{taxon}, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex 
  To load \ty{taxon}, we simulate a join of \ty{nodes.dmp} and
  \ty{names.dmp} on taxon-ID. For this we create the type \ty{taxon}
  with the same five fields as the five attributes in
  Figure~\ref{fig:db}. In addition, we keep a counter of the node's
  children, and note its raw and recursive genome counts per level.
#+end_src
#+begin_src go <<Types, Pa. \ref{pa:tdb}>>=
  type taxon struct {
	  taxid, parent int
	  rank, name, comName string
	  numChildren int
	  raw map[string]int
	  rec map[string]int
  }
#+end_src
#+begin_src latex
  We read the taxa into a map and insert them into the table \ty{taxon}.
#+end_src
#+begin_src go <<Load table \ty{taxon}, Pa. \ref{pa:tdb}>>=
  taxa := make(map[int]*taxon)
  //<<Read taxa, Pa. \ref{pa:tdb}>>
  //<<Insert taxa, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  To read the taxa, we first parse the nodes file, then the names file.
#+end_src
#+begin_src go <<Read taxa, Pa. \ref{pa:tdb}>>=
  //<<Parse nodes file, Pa. \ref{pa:tdb}>>
  //<<Parse names file, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  We traverse the nodes file using a scanner. For each row in the file
  we create a new taxon and split the row into its data fields. Then we
  enter the values for this taxon.
#+end_src
#+begin_src go <<Parse nodes file, Pa. \ref{pa:tdb}>>=
  scanner := bufio.NewScanner(of)
  for scanner.Scan() {
	  row := scanner.Text()
	  t := new(taxon)
	  t.raw = make(map[string]int)
	  t.rec = make(map[string]int)
	  fields := strings.SplitN(row, "\t|\t", 4)
	  //<<Enter taxon values, Pa. \ref{pa:tdb}>>
  }
#+end_src
#+begin_src latex
  We import \ty{bufio} and \ty{strings}.
#+end_src
#+begin_src go <<Imports, Pa. \ref{pa:tdb}>>=
  "bufio"
  "strings"
#+end_src
#+begin_export latex
At this point, we can enter values for three of the five attributes,
\ty{taxid}, \ty{parent}, and \ty{rank}.
#+end_export
#+begin_src go <<Enter taxon values, Pa. \ref{pa:tdb}>>=
  t.taxid, err = strconv.Atoi(fields[0])
  util.Check(err)
  t.parent, err = strconv.Atoi(fields[1])
  util.Check(err)
  t.rank = fields[2]
  taxa[t.taxid] = t
#+end_src
#+begin_export latex
We import \ty{strconv}.
#+end_export
#+begin_src go <<Imports, Pa. \ref{pa:tdb}>>=
  "strconv"
#+end_src
#+begin_src latex
  We again use a scanner to parse the names file and split the columns
  at \verb+\t|\t+. Then we store the taxon-ID, the names.
#+end_src
#+begin_src go <<Parse names file, Pa. \ref{pa:tdb}>>=
  scanner = bufio.NewScanner(af)
  for scanner.Scan() {
	  row := scanner.Text()
	  fields := strings.Split(row, "\t|\t")
	  //<<Store taxon-ID, Pa. \ref{pa:tdb}>>
	  //<<Store names, Pa. \ref{pa:tdb}>>
  }
#+end_src
#+begin_export latex
The taxon-ID is located in the first column. We convert it from string
to integer and check the resulting error.
#+end_export
#+begin_src go <<Store taxon-ID, Pa. \ref{pa:tdb}>>=
  id, err := strconv.Atoi(fields[0])
  util.Check(err)
#+end_src
#+begin_export latex
The names are stored in the second field and the kind of name is
stated in the fourth field. We store the scientific and the genbank
common names.
#+end_export
#+begin_src go <<Store names, Pa. \ref{pa:tdb}>>=
  name := fields[1]
  tag := fields[3][:3]
  if tag == "sci" {
	  taxa[id].name = name
  } else if tag == "gen" {
	  taxa[id].comName = name
  }
#+end_src
#+begin_src latex
  Having read the taxa from the input files, we insert them in the
  \ty{taxon} table. We do this with a transaction, which takes a
  statement and prepares it, before we insert the individual rows.
#+end_src
#+begin_src go <<Insert taxa, Pa. \ref{pa:tdb}>>=
  tx, err := db.Begin()
  util.Check(err)
  sqlStmt = "insert into taxon(taxid, parent, name, " +
	  "common_name, rank) " +
	  "values(?, ?, ?, ?, ?)"
  stmt, err := tx.Prepare(sqlStmt)
  util.Check(err)
  //<<Insert rows into table \ty{taxon}, Pa. \ref{pa:tdb}>>
  tx.Commit()
  stmt.Close()
#+end_src
#+begin_src latex
  Each entry in the \ty{taxa} map corresponds to a row in the table.
#+end_src
#+begin_src go <<Insert rows into table \ty{taxon}, Pa. \ref{pa:tdb}>>=
  for _, v := range taxa {
	  _, err = stmt.Exec(v.taxid, v.parent, v.name,
		  v.comName, v.rank)
	  util.Check(err)
  }
#+end_src
#+begin_src latex
  The next table to load is \ty{genome}. Like the taxa, we read the
  genomes from files. However, the genome tables may contain taxon-IDs
  that have been merged. So we also read the merged table, before we
  insert the genomes into the database.
#+end_src
#+begin_src go <<Load table \ty{genome}, Pa. \ref{pa:tdb}>>=
  //<<Read genomes, Pa. \ref{pa:tdb}>>
  //<<Read merged table, Pa. \ref{pa:tdb}>>
  //<<Insert genomes, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  We read each genome into a struct that holds the four attributes shown
  in Figure~\ref{fig:db}, \ty{taxid}, \ty{accession}, \ty{level}, and
  \ty{size} in Mb. In addition, we declare a switch to indicate whether
  or not the genome has been written to table.
#+end_src
#+begin_src go <<Types, Pa. \ref{pa:tdb}>>=
  type genome struct {
	  taxid int
	  accession, level string
	  size float64
	  written bool
  }
#+end_src
#+begin_src latex
  With a handful of exceptions, the refseq genomes are a subset of the
  genbank genomes. However, the refseq genomes are often better
  annotated. For example, the current version of the human genome has
  genbank accession \ty{GCA\_000001405.29} and refseq accession
  \ty{GCF\_000001405.40}. As you can see, the two accessions have an
  identical central core, but are distinguished by their prefix and
  suffix. They also have distinct annotations. In our example, the
  refseq genome has a total gene count of 59,715, while the genbank
  genome has a total gene count of only 37. So wherever there's a refseq
  genome \emph{and} a genbank genome, as shown by the identical core of
  their accessions, we pick the refseq genome. We also need to take care
  of the handful of refseq genomes not contained in genbank.

  To accomplish this, we store the genomes in a map with the core
  accession as key and the genome as value. First we store the refseq
  genomes, then the genbank genomes.
#+end_src
#+begin_src go <<Read genomes, Pa. \ref{pa:tdb}>>=
  genomes := make(map[string]*genome)
  //<<Store refseq genomes, Pa. \ref{pa:tdb}>>
  //<<Store genbank genomes, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  To store the refseq genomes, we parse the refseq file with a buffered
  scanner. Each row that is not a comment is split into its constituent
  fields. The first field is the accession, which we reduce to its core
  by calling the as yet unwritten function \ty{coreAcc}. The genome is
  constructed by calling \ty{fields2genome}, also still unwritten. Then
  we insert the genome into the map as value to the core accession.
#+end_src
#+begin_src go <<Store refseq genomes, Pa. \ref{pa:tdb}>>=
  scanner = bufio.NewScanner(rf)
  for scanner.Scan() {
	  row := scanner.Text()
	  if row[0] == '#' {
		  continue
	  }
	  fields := strings.Split(row, "\t")
	  k := coreAcc(fields[0])
	  g := fields2genome(fields)
	  genomes[k] = g
  }
#+end_src
#+begin_src latex
  In function \ty{coreAcc} we take an accession consisting of a prefix,
  a core, and a version number, like
  \begin{verbatim}
  pref_core.num
  \end{verbatim}
  and return \ty{core}.
#+end_src
#+begin_src go <<Functions, Pa. \ref{pa:tdb}>>=
  func coreAcc(acc string) string {
	  s := strings.Index(acc, "_") + 1
	  e := strings.Index(acc, ".")
	  core := acc[s:e]
	  return core
  }
#+end_src
#+begin_export latex
\begin{table}
  \caption{The 38 columns in the table of genome accessions supplied
    by the NCBI.}\label{tab:pg}
  \begin{center}
    \begin{tabular}{rlrlrl}
      \hline
      \input{../tdb/acc}\\
      \hline
    \end{tabular}
  \end{center}
\end{table}
In function \ty{fields2genome} we take one row in the accession file
and return a genome. A genome consists of an accession, a taxon-ID, an
assembly level, and a size.
#+end_export
#+begin_src go <<Functions, Pa. \ref{pa:tdb}>>=
  func fields2genome(fields []string) *genome {
	  g := new(genome)
	  //<<Set accession, Pa. \ref{pa:tdb}>>
	  //<<Set taxon-ID, Pa. \ref{pa:tdb}>>
	  //<<Set assembly level, Pa. \ref{pa:tdb}>>
	  //<<Set size, Pa. \ref{pa:tdb}>>
	  return g
  }
#+end_src
#+begin_src latex
  As shown in Table~\ref{tab:pg}, the accession is in the first column.
#+end_src
#+begin_src go <<Set accession, Pa. \ref{pa:tdb}>>=
  g.accession = fields[0]
#+end_src
#+begin_src latex
  The taxon-ID is in the sixth column and we convert it from its string
  representation to integer.
#+end_src
#+begin_src go <<Set taxon-ID, Pa. \ref{pa:tdb}>>=
  id, err := strconv.Atoi(fields[5])
  util.Check(err)
  g.taxid = id
#+end_src
#+begin_src latex
  The assembly level in the 12th column and has values ``Complete
  Genome'', ``Chromosome'', ``Scaffold'', or ``Contig''. We store these
  values in lower case and slightly abbreviated to ``complete'',
  ``chromosome'', ``scaffold'', or ``contig''.
#+end_src
#+begin_src go <<Set assembly level, Pa. \ref{pa:tdb}>>=
  g.level = fields[11]
  g.level = strings.Fields(g.level)[0]
  g.level = strings.ToLower(g.level)
#+end_src
#+begin_src latex
  The size is in the 26th column. It is given in bp, which we divide by
  $10^6$ to convert to Mb.
#+end_src
#+begin_src go <<Set size, Pa. \ref{pa:tdb}>>=
  si, err := strconv.Atoi(fields[25])
  util.Check(err)
  g.size = float64(si) / 1000000.0
#+end_src
#+begin_export latex
We store the genbank genomes that have no entry in our genomes map
yet.
#+end_export
#+begin_src go <<Store genbank genomes, Pa. \ref{pa:tdb}>>=
  scanner = bufio.NewScanner(gf)
  for scanner.Scan() {
	  row := scanner.Text()
	  if row[0] == '#' { continue }
	  fields := strings.Split(row, "\t")
	  k := coreAcc(fields[0])
	  if genomes[k] == nil {
		  g := fields2genome(fields)
		  genomes[k] = g
	  }
  }
#+end_src
#+begin_export latex
The merged table consists of two columns, old taxon-ID and new taxon
ID. Like the nodes and names files, we split the columns of the merged
file at \verb+\t|\t+, which leaves the entry in the last column with a
trailing \verb+\t|+. As we didn't use the last entry before, this
didn't matter. Now, however, we need the entry in the second, that is
last, column. So we remove its trailing \verb+\t|+. Then we are ready
to store the merged table in a map between old and new taxon-IDs.
#+end_export
#+begin_src go <<Read merged table, Pa. \ref{pa:tdb}>>=
  merge := make(map[int]int)
  scanner = bufio.NewScanner(mf)
  for scanner.Scan() {
	  row := scanner.Text()
	  if row[0] == '#' { continue }
	  f := strings.Split(row, "\t|\t")
	  old, err := strconv.Atoi(f[0])
	  util.Check(err)
	  new, err := strconv.Atoi(f[1][:len(f[1])-2])
	  util.Check(err)
	  merge[old] = new
  }
#+end_src
#+begin_src latex
  To insert the genomes into the \ty{genome} table, we use a transaction
  like we did for the \ty{taxon} table. Now, by default transactions in
  sqlite ignore foreign key constraints. So we switch them on to ensure
  the foreign key constraint of \ty{genome} is enforced.
#+end_src
#+begin_src go <<Insert genomes, Pa. \ref{pa:tdb}>>=
  tx, err = db.Begin()
  util.Check(err)
  //<<Switch on foreign keys, Pa. \ref{pa:tdb}>>
  sqlStmt = "insert into genome(accession, " +
	  "taxid, level, size) " +
	  "values(?, ?, ?, ?)"
  stmt, err = tx.Prepare(sqlStmt)
  util.Check(err)
  //<<Insert rows into table \ty{genome}, Pa. \ref{pa:tdb}>>
  tx.Commit()
  stmt.Close()
#+end_src
#+begin_export latex
In sqlite the foreign key constraint is switched on via a pragma that
we execute on the transaction we just prepared.
#+end_export
#+begin_src go <<Switch on foreign keys, Pa. \ref{pa:tdb}>>=
  sqlStmt = "pragma foreign_keys=on"
  _, err = tx.Exec(sqlStmt)
  util.Check(err)
#+end_src
#+begin_src latex
  We iterate over the genomes, perhaps correct their taxon-ID by their
  merged counter, and insert them.
#+end_src
#+begin_src go <<Insert rows into table \ty{genome}, Pa. \ref{pa:tdb}>>=
  for _, genome := range genomes {
	  x := merge[genome.taxid]
	  if x != 0 {
		  genome.taxid = x
	  }
	  _, err = stmt.Exec(genome.accession, genome.taxid,
		  genome.level, genome.size)
	  util.Check(err)
  }
#+end_src
#+begin_export latex
At this point we have processed the genome and taxon data. This allows
us to calculate the genome counts, first the raw counts and from them
the recursive counts. Then we load the genome counts into the database.
#+end_export
#+begin_src go <<Load table \ty{genome\_count}, Pa. \ref{pa:tdb}>>=
  //<<Calculate raw genome counts, Pa. \ref{pa:tdb}>>
  //<<Calculate recursive genome counts, Pa. \ref{pa:tdb}>>
  //<<Enter genome counts, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_export latex
We iterate over the genomes and sum their raw counts per level per
taxon. If we encounter a genome from a taxon that is not in our
collection of taxa, we write a warning.
#+end_export
#+begin_src go <<Calculate raw genome counts, Pa. \ref{pa:tdb}>>=
  for _, genome := range genomes {
	  t := taxa[genome.taxid]
	  if t != nil {
		  t.raw[genome.level]++
	  } else {
		  m := "WARNING[tdb]: no entry in taxonomy for " +
			  "%d referred to by assembly %s; " +
			  "could this be an unmerged taxon?\n"
		  fmt.Fprintf(os.Stderr, m, genome.taxid,
			  genome.accession)
	  }
  }
#+end_src
#+begin_export latex
To calculate the recursive genome counts, we initialize them to the
raw counts. In the actual recursion we carry out a bottom-up tree
traversal by first iterating over the taxonomy's leaves. The parents
of these leaves become ``leaves'' in the next round, until there are
no leaves left. So we need to determine the initial set of leaves, the
actual leaves in the taxonomy. Then we iterate for as long as we have
leaves. In every round we analyze each leaf and reslice to get the new
set of pseudo-leaves.
#+end_export
#+begin_src go <<Calculate recursive genome counts, Pa. \ref{pa:tdb}>>=
  //<<Initialize recursive to raw counts, Pa. \ref{pa:tdb}>>
  leaves := []*taxon{}
  //<<Find leaves in taxonomy, Pa. \ref{pa:tdb}>>
  for len(leaves) > 0 {
	  i := 0
	  for _, leaf := range leaves {
		  //<<Analyze leaf, Pa. \ref{pa:tdb}>>
	  }
	  leaves = leaves[:i]
  }
#+end_src
#+begin_export latex
We iterate over the taxa and initialize the recursive counts to the
raw counts.
#+end_export
#+begin_src go <<Initialize recursive to raw counts, Pa. \ref{pa:tdb}>>=
  for _, taxon := range taxa {
	  for level, count := range taxon.raw {
		  taxon.rec[level] = count
	  }
  }
#+end_src
#+begin_export latex
To find the leaves in the taxonomy, we note that leaves have no
children. So we count the nodes' children, before we store the leaves.
#+end_export
#+begin_src go <<Find leaves in taxonomy, Pa. \ref{pa:tdb}>>=
  //<<Count children, Pa. \ref{pa:tdb}>>
  //<<Store leaves, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_export latex
We iterate over the taxa and look up their parents. In a complete
taxonomy, there is only one node that doesn't have a parent, the
root. Its taxon-ID is identical to that of its parent. However, we
might not be dealing with a complete taxonomy, in which case the
current node's parent is nil. We check for both cases and if the
current node does have a parent, we increment its child count.
#+end_export
#+begin_src go <<Count children, Pa. \ref{pa:tdb}>>=
  for _, taxon := range taxa {
	  parent := taxa[taxon.parent]
	  if parent != nil && parent.taxid != taxon.taxid {
		  parent.numChildren++
	  }
  }
#+end_src
#+begin_export latex
We iterate over the taxa and store those with zero children in our
initial slice of leaves.
#+end_export
#+begin_src go <<Store leaves, Pa. \ref{pa:tdb}>>=
  for _, taxon := range taxa {
	  if taxon.numChildren == 0 {
		  leaves = append(leaves, taxon)
	  }
  }
#+end_src
#+begin_export latex
When analyzing a leaf, we find its parent, update the parent's genome
count, and adjust the leaf list.
#+end_export
#+begin_src go <<Analyze leaf, Pa. \ref{pa:tdb}>>=
  var parent *taxon
  //<<Find parent, Pa. \ref{pa:tdb}>>
  //<<Update parent's genome count, Pa. \ref{pa:tdb}>>
  //<<Adjust leaf list, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_export latex
If the current node has no parent, there's nothing to be done and we
skip the rest of this round of the iteration.
#+end_export
#+begin_src go <<Find parent, Pa. \ref{pa:tdb}>>=
  parent = taxa[leaf.parent]
  if parent == nil || leaf.taxid == parent.taxid {
	  continue
  }
#+end_src
#+begin_export latex
We update the parent's recursive genome count for all levels.
#+end_export
#+begin_src go <<Update parent's genome count, Pa. \ref{pa:tdb}>>=
  for level, count := range leaf.rec {
	parent.rec[level] += count
  }
#+end_src
#+begin_export latex
We decrement the parents child count. If this is now zero, we add it
to the leaf list for the next round.
#+end_export
#+begin_src go <<Adjust leaf list, Pa. \ref{pa:tdb}>>=
  parent.numChildren--
  if parent.numChildren == 0 {
	  leaves[i] = parent
	  i++
  }
#+end_src
#+begin_export latex
To enter the genome counts, we generate the transaction for storing
the genome counts, switch on the foreign keys constraint, and insert
the genome counts.
#+end_export
#+end_export
#+begin_src go <<Enter genome counts, Pa. \ref{pa:tdb}>>=
  tx, err = db.Begin()
  util.Check(err)
  //<<Switch on foreign keys, Pa. \ref{pa:tdb}>>
  sqlStmt = `insert into genome_count(
  level, recursive, raw, taxid)
  values(?, ?, ?, ?)`
  stmt, err = tx.Prepare(sqlStmt)
  util.Check(err)
  //<<Insert genome counts, Pa. \ref{pa:tdb}>>
  tx.Commit()
  stmt.Close()
#+end_src
#+begin_export latex
We iterate over the taxa and insert their raw and recursive genome
counts per level.
#+end_export
#+begin_src go <<Insert genome counts, Pa. \ref{pa:tdb}>>=
  for _, t := range taxa {
	  for _, level := range assemblyLevels {
		  recCount := t.rec[level]
		  rawCount := t.raw[level]
		  _, err = stmt.Exec(level,
			  recCount, rawCount, t.taxid)
		  util.Check(err)
	  }
  }
#+end_src
#+begin_export latex
We store the four possible assembly levels in the global variable
\ty{assemblyLevels}.
#+end_export
#+begin_src go <<Variables, Pa. \ref{pa:tdb}>>=
  var assemblyLevels = []string{"complete",
	  "chromosome",
	  "scaffold",
	  "contig"}
#+end_src
#+begin_export latex
We update the scores using a transaction that we prepare, before doing
the actual updating. Then we commit the transaction and close it again.
#+end_export
#+begin_src go <<Enter score in table \ty{taxon}, Pa. \ref{pa:tdb}>>=
  tx, err = db.Begin()
  util.Check(err)
  sqlStmt = `update taxon
    set score = ?
    where taxid = ?`
  stmt, err = tx.Prepare(sqlStmt)
  util.Check(err)
  //<<Update score, Pa. \ref{pa:tdb}>>
  tx.Commit()
  stmt.Close()
#+end_src
#+begin_export latex
We iterate over the taxa. For each taxon we calculate the score as the
sum of the recursive genome counts across the assembly levels. This
value is then used to update the database entry.
#+end_export
#+begin_src go <<Update score, Pa. \ref{pa:tdb}>>=
  for _, taxon := range taxa {
	  sum := 0
	  for _, count := range taxon.rec {
		  sum += count
	  }
	  _, err := stmt.Exec(sum, taxon.taxid)
	  util.Check(err)
  }
#+end_src
#+begin_src latex
  \subsection{\ty{OpenTaxonomyDB}}
  ! The function \ty{OpenTaxonomyDB} opens an existing taxonomy database
  ! and returns a pointer to it.
#+end_src
#+begin_src go <<Functions, Pa. \ref{pa:tdb}>>=
  func OpenTaxonomyDB(name string) *TaxonomyDB {
	  db := new(TaxonomyDB)
	  var err error
	  db.db, err = sql.Open("sqlite3", name)
	  util.Check(err)
	  _, err = db.db.Exec("PRAGMA foreign_keys = ON;")
	  util.Check(err)
	  return db
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Close}}
  ! The method \ty{Close} closes a taxonomy database.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Close() {
	  t.db.Close()
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Accessions}}
  !The method \ty{Accessions} takes as parameter a taxon-ID and returns
  !a slice accessions of genome assemblies belonging to that taxon and
  !an error.

  We query for accessions and then store them in the global string slice
  we return.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Accessions(taxon int) ([]string, error) {
	  var err error
	  accessions := make([]string, 0)
	  //<<Query for accessions, Pa. \ref{pa:tdb}>>
	  //<<Store accessions, Pa. \ref{pa:tdb}>>
	  return accessions, err
  }
#+end_src
#+begin_src latex
  We begin querying by defining a template for querying accessions.
#+end_src
#+begin_src go <<Query templates, Pa. \ref{pa:tdb}>>= 
  var accessionT = "select accession " +
	  "from genome " +
	  "where taxid=%d"
#+end_src
#+begin_export latex
We construct the query for accessions from our template and run it. We
make sure that the input stream returned is eventually closed again
and check the error returned by the database.
#+end_export
#+begin_src go <<Query for accessions, Pa. \ref{pa:tdb}>>=
  q := fmt.Sprintf(accessionT, taxon)
  rows, err := t.db.Query(q)
  defer rows.Close()
  if err != nil {
	  return nil, err
  }
#+end_src
#+begin_src latex
  We append each accession to our slice of accessions.
#+end_src
#+begin_src go <<Store accessions, Pa. \ref{pa:tdb}>>=
  accession := ""
  for rows.Next() {
	  err := rows.Scan(&accession)
	  if err != nil {
		  return nil, err
	  }
	  accessions = append(accessions, accession)
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Name}}
  ! The method \ty{Name} takes as argument a taxon-ID and returns the
  ! taxon's name and an error.

  We construct the query, execute it, and extract the name.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Name(taxon int) (string, error) {
	  var err error
	  name := ""
	  //<<Construct name query, Pa. \ref{pa:tdb}>>
	  //<<Execute name query, Pa. \ref{pa:tdb}>>
	  //<<Extract name, Pa. \ref{pa:tdb}>>
	  return name, err
  }
#+end_src
#+begin_src latex
  To construct the name query, we define a template.
#+end_src
#+begin_src go <<Query templates, Pa. \ref{pa:tdb}>>=
  var nameT = "select name from taxon where taxid=%d"
#+end_src
#+begin_src latex
  We construct the query from our new template.
#+end_src
#+begin_src go <<Construct name query, Pa. \ref{pa:tdb}>>=
  q := fmt.Sprintf(nameT, taxon)
#+end_src
#+begin_src latex
  We execute the query, which might throw an error. We also close the
  results table once we're done with it.
#+end_src
#+begin_src go <<Execute name query, Pa. \ref{pa:tdb}>>=
  rows, err := t.db.Query(q)
  defer rows.Close()
  if err != nil {
	  return "", err
  }
#+end_src
#+begin_src latex
  Our results table contains only the requested single name. We scan
  this and catch potential errors.
#+end_src
#+begin_src go <<Extract name, Pa. \ref{pa:tdb}>>=
  rows.Next()
  err = rows.Scan(&name)
  if err != nil {
	  return "", err
  }
#+end_src

#+begin_src latex
  \subsection{\ty{CommonName}}
  ! The method \ty{CommonName} takes as argument a taxon-ID and returns the
  ! taxon's common name and an error.

  We construct the common name query, execute it, and extract the name.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) CommonName(taxon int) (string, error) {
	  var err error
	  commonName := ""
	  //<<Construct common name query, Pa. \ref{pa:tdb}>>
	  //<<Execute common name query, Pa. \ref{pa:tdb}>>
	  //<<Extract common name, Pa. \ref{pa:tdb}>>
	  return commonName, err
  }
#+end_src
#+begin_src latex
  To construct the common name query, we define a template.
#+end_src
#+begin_src go <<Query templates, Pa. \ref{pa:tdb}>>=
  var commonNameT = "select common_name " +
	  "from taxon where taxid=%d"
#+end_src
#+begin_src latex
  We construct the common name query from our new template.
#+end_src
#+begin_src go <<Construct common name query, Pa. \ref{pa:tdb}>>=
  q := fmt.Sprintf(commonNameT, taxon)
#+end_src
#+begin_src latex
  We execute the common name query, which might throw an error. We also
  close the results table once we're done with it.
#+end_src
#+begin_src go <<Execute common name query, Pa. \ref{pa:tdb}>>=
  rows, err := t.db.Query(q)
  defer rows.Close()
  if err != nil {
	  return "", err
  }
#+end_src
#+begin_src latex
  Our results table contains only the requested single name. We scan
  this and catch potential errors.
#+end_src
#+begin_src go <<Extract common name, Pa. \ref{pa:tdb}>>=
  rows.Next()
  err = rows.Scan(&commonName)
  if err != nil {
	  return "", err
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Rank}}
  !The method \ty{Rank} takes as argument a taxon-ID and returns the
  !taxon's rank and an error.

  We construct the query, execute it, and extract the rank.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Rank(taxon int) (string, error) {
	  var err error
	  rank := ""
	  //<<Construct rank query, Pa. \ref{pa:tdb}>>
	  //<<Execute rank query, Pa. \ref{pa:tdb}>>
	  //<<Extract rank, Pa. \ref{pa:tdb}>>
	  return rank, err
  }
#+end_src
#+begin_src latex
  To construct the rank query, we first define a template.
#+end_src
#+begin_src go <<Query templates, Pa. \ref{pa:tdb}>>=
  var rankT = "select rank from taxon where taxid=%d"
#+end_src
#+begin_src latex
  We construct the rank query from its template.
#+end_src
#+begin_src go <<Construct rank query, Pa. \ref{pa:tdb}>>=
  q := fmt.Sprintf(rankT, taxon)
#+end_src
#+begin_src latex
  We execute the rank query, which might throw an error. We also close
  the results table once we're done with it.
#+end_src
#+begin_src go <<Execute rank query, Pa. \ref{pa:tdb}>>=
  rows, err := t.db.Query(q)
  defer rows.Close()
  if err != nil {
	  return "", err
  }
#+end_src
#+begin_src latex
  Our results table contains only the requested single rank. We scan
  this and catch potential errors.
#+end_src
#+begin_src go <<Extract rank, Pa. \ref{pa:tdb}>>=
  rows.Next()
  err = rows.Scan(&rank)
  if err != nil {
	  return "", err
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Parent}}
  ! The method \ty{Parent} takes as argument a taxon-ID and returns the
  ! taxon-ID of its parent and an error.

  We construct the query, execute it, and extract the parent.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Parent(c int) (int, error) {
	  var err error
	  parent := 0
	  //<<Construct parent query, Pa. \ref{pa:tdb}>>
	  //<<Execute parent query, Pa. \ref{pa:tdb}>>
	  //<<Extract parent, Pa. \ref{pa:tdb}>>
	  return parent, err
  }
#+end_src
#+begin_src latex
  We define the template for the parent query.
#+end_src
#+begin_src go <<Query templates, Pa. \ref{pa:tdb}>>=
  var parentT = "select parent from taxon where taxid=%d"
#+end_src
#+begin_src latex
  We construct the parent query from its query.
#+end_src
#+begin_src go <<Construct parent query, Pa. \ref{pa:tdb}>>=
  q := fmt.Sprintf(parentT, c)
#+end_src
#+begin_src latex
  We execute the query to get the results table. Query execution might
  throw an error, which we catch. We also make sure the results table is
  eventually closed again.
#+end_src
#+begin_src go <<Execute parent query, Pa. \ref{pa:tdb}>>=
  rows, err := t.db.Query(q)
  defer rows.Close()
  if err != nil {
	  return 0, err
  }
#+end_src
#+begin_src latex
  Our results table contains at most one row with one entry, the
  parent. We extract this and catch possible errors.
#+end_src
#+begin_src go <<Extract parent, Pa. \ref{pa:tdb}>>=
  rows.Next()
  err = rows.Scan(&parent)
  if err != nil {
	  return 0, err
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Children}}
  ! The method \ty{Children} takes as argument a taxon-ID and returns its
  ! children and an error.

  We construct the children query, execute it, and extract the children.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Children(p int) ([]int, error) {
	  var err error
	  children := make([]int, 0)
	  //<<Construct children query, Pa. \ref{pa:tdb}>>
	  //<<Execute children query, Pa. \ref{pa:tdb}>>
	  //<<Extract children, Pa. \ref{pa:tdb}>>
	  return children, err
  }
#+end_src
#+begin_src latex
  We define a template for the children query.
#+end_src
#+begin_src go <<Query templates, Pa. \ref{pa:tdb}>>=
  var childrenT = "select taxid from taxon where parent=%d"
#+end_src
#+begin_src latex
  We construct the children query from its template and the parent
  passed.
#+end_src
#+begin_src go <<Construct children query, Pa. \ref{pa:tdb}>>=
  q := fmt.Sprintf(childrenT, p)
#+end_src
#+begin_src latex
  We execute the children query to get the results table, catch errors,
  and eventually close the results table again.
#+end_src
#+begin_src go <<Execute children query, Pa. \ref{pa:tdb}>>=
  rows, err := t.db.Query(q)
  defer rows.Close()
  if err != nil {
	  return nil, err
  }
#+end_src
#+begin_src latex
  We copy the children into the slice we've prepared for this purpose.
#+end_src
#+begin_src go <<Extract children, Pa. \ref{pa:tdb}>>=
  child := 0
  for rows.Next() {
	  err = rows.Scan(&child)
	  if err != nil {
		  return nil, err
	  }
	  children = append(children, child)
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Subtree}}
  ! The method \ty{Subtree} returns all taxa in a subtree, including its
  ! root, and an error.

  It looks up the taxa in the subtree by calling the private function
  \ty{traverseSubtree}.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Subtree(r int) ([]int, error) {
	  var err error
	  taxa := make([]int, 0)
	  taxa, err = traverseSubtree(t, r, taxa)
	  if err != nil {
		  return nil, err
	  }
	  return taxa, err
  }
#+end_src
#+begin_src latex
  In \ty{traverseSubtree} we append the incoming node to the slice
  of taxa and iterate over the node's children.
#+end_src
#+begin_src go <<Functions, Pa. \ref{pa:tdb}>>=
  func traverseSubtree(t *TaxonomyDB, v int, taxa []int) ([]int, error) {
	  taxa = append(taxa, v)
	  children, err := t.Children(v)
	  if err != nil {
		  return nil, err
	  }
	  //<<Iterate over children, Pa. \ref{pa:tdb}>>
	  return taxa, err
  }
#+end_src
#+begin_export latex
We iterate over the children and call \ty{traverseSubtree} on each of
them, unless it is identical to the parent, which would give us an
infinite loop.
#+end_export
#+begin_src go <<Iterate over children, Pa. \ref{pa:tdb}>>=
  for _, child := range children {
	  if child != v {
		  taxa, err = traverseSubtree(t, child, taxa)
		  if err != nil {
			  return nil, err
		  }
	  }
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Taxids}}
  ! \ty{Taxids} takes as arguments a taxon name, a limit on the number
  ! of names returned, and an offset into the list of matching names. It
  ! matches the taxon name, to the scientific names in the database,
  ! orders the hits by their score, imposes the limit and offset, and
  ! returns the corresponding taxon-IDs and an error.

  We construct and execute the query for taxon-IDs, extract the IDs, and
  return them.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Taxids(name string,
	  limit, offset int) ([]int, error) {
	  var err error
	  taxids := make([]int, 0)
	  //<<Construct taxids query, Pa. \ref{pa:tdb}>>
	  //<<Execute taxids query, Pa. \ref{pa:tdb}>>
	  //<<Extract taxids, Pa. \ref{pa:tdb}>>
	  return taxids, err
  }
#+end_src
#+begin_src latex
  We declare a template for the taxids query, where we order the
  matching names by their score in descending order before ordering by
  name and then imposing paging.
#+end_src
#+begin_src go <<Query templates, Pa. \ref{pa:tdb}>>=
  var taxidsT = "select taxid from taxon " +
	  "where name like '%s' " +
	  "order by score desc, name " +
	  "limit %d " +
	  "offset %d"
#+end_src
#+begin_src latex
  We construct the query for taxon-IDs from its template.
#+end_src
#+begin_src go <<Construct taxids query, Pa. \ref{pa:tdb}>>=
  q := fmt.Sprintf(taxidsT, name, limit, offset)
#+end_src
#+begin_src latex
  We execute the query for taxon-IDs and catch potential errors. We also
  make sure the result table is eventually closed again.
#+end_src
#+begin_src go <<Execute taxids query, Pa. \ref{pa:tdb}>>=
  rows, err := t.db.Query(q)
  defer rows.Close()
  if err != nil {
	  return nil, err
  }
#+end_src
#+begin_src latex
  We extract and store the taxon-IDs.
#+end_src
#+begin_src go <<Extract taxids, Pa. \ref{pa:tdb}>>=
  taxid := 0
  for rows.Next() {
	  err = rows.Scan(&taxid)
	  if err != nil {
		  return nil, err
	  }
	  taxids = append(taxids, taxid)
  }
#+end_src
#+begin_src latex
  \subsection{\ty{CommonTaxids}}
  ! \ty{CommonTaxids} takes as arguments a taxon name, a limit on the
  ! number of names returned, and an offset into the list of matching
  ! names. It matches the taxon name to the scientific and common names,
  ! orders the hits by their score, imposes the limit and offset, and
  ! returns the corresponding taxon-IDs and an error.

  We construct and execute the query for taxon-IDs from common and
  scientific names, extract the IDs, and return them.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) CommonTaxids(name string,
	  limit, offset int) ([]int, error) {
	  var err error
	  commonTaxids := make([]int, 0)
	  //<<Construct common taxids query, Pa. \ref{pa:tdb}>>
	  //<<Execute common taxids query, Pa. \ref{pa:tdb}>>
	  //<<Extract common taxids, Pa. \ref{pa:tdb}>>
	  return commonTaxids, err
  }
#+end_src
#+begin_src latex
  We declare a template for the taxids query, where we order the
  matching names by their score in descending order and name in
  ascending order, before imposing paging.
#+end_src
#+begin_src go <<Query templates, Pa. \ref{pa:tdb}>>=
  var commonTaxidsT = "select taxid from taxon " +
	  "where name like '%s' " +
	  "or common_name like '%s' " +
	  "order by score desc, name " +
	  "limit %d " +
	  "offset %d"
#+end_src
#+begin_src latex
  We construct the query for taxon-IDs from its template.
#+end_src
#+begin_src go <<Construct common taxids query, Pa. \ref{pa:tdb}>>=
  q := fmt.Sprintf(commonTaxidsT, name, name, limit, offset)
#+end_src
#+begin_src latex
  We execute the query for taxon-IDs and catch potential errors. We also
  make sure the result table is eventually closed again.
#+end_src
#+begin_src go <<Execute common taxids query, Pa. \ref{pa:tdb}>>=
  rows, err := t.db.Query(q)
  defer rows.Close()
  if err != nil {
	  return nil, err
  }
#+end_src
#+begin_src latex
  We extract and store the taxon-IDs.
#+end_src
#+begin_src go <<Extract common taxids, Pa. \ref{pa:tdb}>>=
  taxid := 0
  for rows.Next() {
	  err = rows.Scan(&taxid)
	  if err != nil {
		  return nil, err
	  }
	  commonTaxids = append(commonTaxids, taxid)
  }
#+end_src
#+begin_src latex
  \subsection{\ty{MRCA}}
  !The method \ty{MRCA} takes as input a slice of taxon-IDs and returns
  !their most recent common ancestor and an error.

  For example, in Figure~\ref{fig:tax}, the most recent common ancestor
  of taxa 4 and 7 is 3. We begin by checking the IDs supplied and then
  search for the MRCA. If we haven't found one, we return -1.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) MRCA(ids []int) (int, error) {
	  var err error
	  mrca := -1
	  //<<Check IDs, Pa. \ref{pa:tdb}>>
	  //<<Search for MRCA, Pa. \ref{pa:tdb}>>
	  return mrca, err
  }
#+end_src
#+begin_src latex
If the ID list is empty, something went wrong and we throw an
error. If the ID list contains a single entry, that is the MRCA.
#+end_src
#+begin_src go <<Check IDs, Pa. \ref{pa:tdb}>>=
  if len(ids) == 0 {
	  m := "Empty ID list in tdb.MRCA"
	  return 0, errors.New(m)
  } else if len(ids) == 1 {
	  return ids[0], nil
  }
#+end_src
#+begin_export latex
We import \ty{errors}.
#+end_export
#+begin_src go <<Imports, Pa. \ref{pa:tdb}>>=
  "errors"
#+end_src
#+begin_src latex
There is a rich history of MRCA queries in computer
science~\cite[ch. 3]{ohl13:bio}. However, instead of using the general
solution to the problem, I construct a simpler solution that involves
climbing to the common ancestor of a set of taxa. If these taxa are
closely related, the climb is short.

To be more precise, in each step of our climb, we increment a
descendant counter for each node. If one of these counters is equal to
the number of input taxa, the corresponding node is the
MRCA. Otherwise, we climb to the parents and repeat. So we construct a
variable to count descendants and variables for parents and
children. Then we iterate over the parents.
#+end_src
#+begin_src go <<Search for MRCA, Pa. \ref{pa:tdb}>>=
  //<<Construct counter for descendants, Pa. \ref{pa:tdb}>>
  //<<Construct variables for parents and children, Pa. \ref{pa:tdb}>>
  //<<Iterate over parents, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
We store descendants in a map between a taxon-ID, which is an integer,
and the number of its descendants, another integer. The initial number
of descendants of the taxa supplied is one.
#+end_src
#+begin_src go <<Construct counter for descendants, Pa. \ref{pa:tdb}>>=
  desc := make(map[int]int)
  for _, id := range ids {
	  desc[id] = 1
  }
#+end_src
#+begin_src latex
We store the parent and child taxa as integer slices. The children
slice is initialized to the taxon-IDs supplied.
#+end_src
#+begin_src go <<Construct variables for parents and children, Pa. \ref{pa:tdb}>>=
  parents := make([]int, 0)
  children := make([]int, 0)
  for _, id := range ids {
	  children = append(children, id)
  }
#+end_src
#+begin_src latex
  As long as we have more than one child, i. e. haven't reached the root
  yet, we climb to the next set of parents and replace the children by
  the parents.
#+end_src
#+begin_src go <<Iterate over parents, Pa. \ref{pa:tdb}>>=
  for len(children) > 1 {
	  //<<Climb to parents, Pa. \ref{pa:tdb}>>
	  //<<Replace parents by children, Pa. \ref{pa:tdb}>>
  }
#+end_src
#+begin_src latex
  For each parent we reach, we check whether the number of its
  descendants is greater or equal to the number of taxa submitted. If
  yes, we've found the MRCA and return it.
#+end_src
#+begin_src go <<Climb to parents, Pa. \ref{pa:tdb}>>=
  for _, child := range children {
	  parent, err := t.Parent(child)
	  if err != nil {
		  return 0, err
	  }
	  desc[parent] += desc[child]
	  if desc[parent] >= len(ids) {
		  mrca = parent
		  break
	  }
	  parents = append(parents, parent)
  }
#+end_src
#+begin_src latex
If the MRCA hasn't been found yet, we replace the children by the
parent and reset the parent slice to empty.
#+end_src
#+begin_src go <<Replace parents by children, Pa. \ref{pa:tdb}>>=
  if mrca == -1 {
	  children = children[:0]
	  for _, parent := range parents {
		  children = append(children, parent)
	  }
	  parents = parents[:0]
  } else {
	  break
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Level}}
  ! The method \ty{Level} takes as argument a genome accession and
  ! returns the assembly level and an eror.

  We construct the level query, execute it, and extract the level before
  we return it.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Level(acc string) (string, error) {
	  var err error
	  level := ""
	  //<<Construct level query, Pa. \ref{pa:tdb}>>
	  //<<Execute level query, Pa. \ref{pa:tdb}>>
	  //<<Extract level, Pa. \ref{pa:tdb}>>
	  return level, err
  }
#+end_src
#+begin_src latex
  We define a template for the level query.
#+end_src
#+begin_src go <<Query templates, Pa. \ref{pa:tdb}>>=
  var levelT = "select level from genome where accession='%s'"
#+end_src
#+begin_src latex
  We construct the level query from its template.
#+end_src
#+begin_src go <<Construct level query, Pa. \ref{pa:tdb}>>=
  q := fmt.Sprintf(levelT, acc)
#+end_src
#+begin_src latex
  We execute the level query, check the error, and make sure the result
  stream we just opened is eventually closed again.
#+end_src
#+begin_src go <<Execute level query, Pa. \ref{pa:tdb}>>=
  rows, err := t.db.Query(q)
  defer rows.Close()
  if err != nil {
	  return "", err
  }
#+end_src
#+begin_src latex
  We scan the first row in the table and check the error returned.
#+end_src
#+begin_src go <<Extract level, Pa. \ref{pa:tdb}>>=
  rows.Next()
  err = rows.Scan(&level)
  if err != nil {
	  return "", err
  }
#+end_src
#+begin_src latex
  \subsection{\ty{FilterAccessions}}
  ! \ty{FilterAccessions} takes as input a slice of genome accessions
  ! and a list of desired assembly levels. It then removes any accession
  ! that doesn't conform to one of the levels supplied and returns the
  ! adjusted slice of genome accessions and an error. The input
  ! accessions remain unchanged.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (d *TaxonomyDB) FilterAccessions(acc []string,
	  levels map[string]bool) ([]string, error) {
	  newAcc := []string{}
	  var err error
	  //<<Remove accessions with wrong level, Pa. \ref{pa:tdb}>>
	  return newAcc, err
  }
#+end_src
#+begin_src latex
  For each of the genome accessions supplied, we look up the assembly
  level. If the level conforms to one of the desired levels, we store
  the accession in a new slice of accessions, which we return at the
  end.
#+end_src
#+begin_src go <<Remove accessions with wrong level, Pa. \ref{pa:tdb}>>=
  for _, a := range acc {
	  level, err := d.Level(a)
	  if err != nil {
		  return nil, err
	  }
	  if levels[level] {
		  newAcc = append(newAcc, a)
	  }
  }
#+end_src
#+begin_export latex
\subsection{\ty{NumTaxa}}
! The method \ty{NumTaxa} returns the number of taxa in the database
! and an error.

We construct the query for the number of taxa, execute it, and extract
the result.
#+end_export
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (d *TaxonomyDB) NumTaxa() (int, error) {
	  n := 0
	  var err error
	  //<<Construct numtax query, Pa. \ref{pa:tdb}>>
	  //<<Execute numtax query, Pa. \ref{pa:tdb}>>
	  //<<Extract numtax, Pa. \ref{pa:tdb}>>
	  return n, err
  }
#+end_src
#+begin_export latex
The query for the number of taxa is a single line of SQL.
#+end_export
#+begin_src go <<Construct numtax query, Pa. \ref{pa:tdb}>>=
  q := "select count(*) from taxon"
#+end_src
#+begin_export latex
We execute our query, store the table row returned, and check the
error.
#+end_export
#+begin_src go <<Execute numtax query, Pa. \ref{pa:tdb}>>=
  row, err := d.db.Query(q)
  defer row.Close()
  if err != nil {
	  return 0, err
  }
#+end_src
#+begin_export latex
We extract the number of taxa from the table row and check the error.
#+end_export
#+begin_src go <<Extract numtax, Pa. \ref{pa:tdb}>>=
  row.Next()
  err = row.Scan(&n)
  if err != nil {
	  return 0, err
  }
#+end_src
#+begin_export latex
\subsection{\ty{NumGenomes}}
!The method \ty{NumGenomes} takes as argument a taxon-ID and an
!assembly level and returns the raw number of genomes associated with
!this taxon assembled to that level and an error.
!
!NB: This is not the number of genomes in the subtree rooted on that
!taxon, please use the method NumGenomesRecursive for that.

We construc the query for the number of genomes, execute it, and
extract the result.
#+end_export
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (d *TaxonomyDB) NumGenomes(taxid int, level string) (int, error) {
	  n := 0
	  var err error
	  //<<Construct numgen query, Pa. \ref{pa:tdb}>>
	  //<<Execute numgen query, Pa. \ref{pa:tdb}>>
	  //<<Extract numgen, Pa. \ref{pa:tdb}>>
	  return n, err
  }
#+end_src
#+begin_export latex
We look up the desired number of genomes in the table
\ty{genome\_count}.
#+end_export
#+begin_src go <<Construct numgen query, Pa. \ref{pa:tdb}>>=
  q := "select raw from genome_count " +
	  "where taxid=%d and " +
	  "level like '%s'"
  q = fmt.Sprintf(q, taxid, level)
#+end_src
#+begin_export latex
We execute the query, store the table row returned, and check the
error.
#+end_export
#+begin_src go <<Execute numgen query, Pa. \ref{pa:tdb}>>=
  row, err := d.db.Query(q)
  defer row.Close()
  if err != nil {
	  return 0, err
  }
#+end_src
#+begin_export latex
We extract the number of genomes from the table row and check the
error.
#+end_export
#+begin_src go <<Extract numgen, Pa. \ref{pa:tdb}>>=
  row.Next()
  err = row.Scan(&n)
  if err != nil {
	  return 0, err
  }
#+end_src
#+begin_export latex
\subsection{\ty{NumGenomesRec}}
!The method \ty{NumGenomesRec} takes as argument a taxon-ID and an
!assembly level. It returns the number of genomes assembled to that
!level contained in the subtree rooted on the taxon-ID and an error.

We construct the query for the recursive number of genomes, execute
the query, and extract the result.
#+end_export
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (d *TaxonomyDB) NumGenomesRec(taxid int, level string) (int, error) {
	  n := 0
	  var err error
	  //<<Construct recursive numgen query, Pa. \ref{pa:tdb}>>
	  //<<Execute recursive numgen query, Pa. \ref{pa:tdb}>>
	  //<<Extract recursive numgen, Pa. \ref{pa:tdb}>>
	  return n, err
  }
#+end_src
#+begin_export latex
We look up the recursive number of genomes for the input taxon
assembled to the desired level in table \ty{genome\_count}.
#+end_export
#+begin_src go <<Construct recursive numgen query, Pa. \ref{pa:tdb}>>=
  q := "select recursive from genome_count " +
	  "where taxid=%d and " +
	  "level like '%s'"
  q = fmt.Sprintf(q, taxid, level)
#+end_src
#+begin_export latex
We execute the query for the recursive number of genomes and check the
error.
#+end_export
#+begin_src go <<Execute recursive numgen query, Pa. \ref{pa:tdb}>>=
  row, err := d.db.Query(q)
  defer row.Close()
  if err != nil {
	  return 0, err
  }
#+end_src
#+begin_export latex
We extract the recursive number of genomes from the row returned by
the query. And keep checking the error.
#+end_export
#+begin_src go <<Extract recursive numgen, Pa. \ref{pa:tdb}>>=
  row.Next()
  err = row.Scan(&n)
  if err != nil {
	  return 0, err
  }
#+end_src
#+begin_export latex
\subsection{\ty{AssemblyLevels}}
!The function \ty{AssemblyLevels} returns the slice of possible
!assembly levels.
#+end_export
#+begin_src go <<Functions, Pa. \ref{pa:tdb}>>=
  func AssemblyLevels() []string {
	  return assemblyLevels
  }
#+end_src
#+begin_src latex
  \subsection{Testing}
  We test on the \emph{Homininae} subfamily shown in
  Figure~\ref{fig:hom}.
  \begin{figure}
    \begin{center}
      \scalebox{0.4}{\includegraphics{../tdb/hom}}
    \end{center}
    \caption{Taxonomy of the \emph{Homininae} subfamily; colored nodes
      contain genomes.}\label{fig:hom}
  \end{figure}
  The outline of our code for testing \ty{tdb} has a hook for the
  testing logic.
#+end_src
#+begin_src go <<tdb_test.go>>=
  package tdb

  import (
	  "testing"
  )

  func TestTdb(t *testing.T) {
	  //<<Testing, Pa. \ref{pa:tdb}>>
  }
#+end_src
#+begin_export latex
We first test the functions, then the methods.
#+end_export
#+begin_src go <<Testing, Pa. \ref{pa:tdb}>>=
  //<<Test functions, Pa. \ref{pa:tdb}>>
  //<<Test methods, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_export latex
There are two functions, \ty{NewTaxonomyDB} and \ty{AssemblyLevels}.
#+end_export
#+begin_src go <<Test functions, Pa. \ref{pa:tdb}>>=
  //<<Test \ty{NewTaxonomyDB}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{AssemblyLevels}, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  To test the function \ty{NewTaxonomyDB}, we build a small database,
  \ty{taxSmall.db}.
#+end_src
#+begin_src go <<Test \ty{NewTaxonomyDB}, Pa. \ref{pa:tdb}>>=
  p := "../data/"
  no := p + "nodesTest.dmp"
  na := p + "namesTest.dmp"
  me := p + "mergedTest.dmp"
  gb := p + "gbTest.txt"
  rs := p + "rsTest.txt"
  db := p + "taxSmall.db"
  NewTaxonomyDB(no, na, me, gb, rs, db)
#+end_src
#+begin_src latex
  We extract the full taxonomy from the small database and check it has
  26 entries.
#+end_src
#+begin_src go <<Test \ty{NewTaxonomyDB}, Pa. \ref{pa:tdb}>>=
  taxdb := OpenTaxonomyDB(db)
  subtree, _ := taxdb.Subtree(207598)
  if len(subtree) != 26 {
	  t.Errorf("get %d rows, want 26", len(subtree))
	  for _, s := range subtree {
		  println(s)
	  }
  }
#+end_src
#+begin_export latex
To test the function \ty{AssemblyLevels}, we make sure it returns four
levels.
#+end_export
#+begin_src go <<Test \ty{AssemblyLevels}, Pa. \ref{pa:tdb}>>=
  nl := len(AssemblyLevels())
  if nl != 4 {
	  t.Errorf("get %d assembly levels, want 4", nl)
  }
#+end_src
#+begin_export latex
Having tested the functions, we test the methods. We do this in three
lots, depending on which table to access, \ty{genome}, \ty{accession},
or \ty{genome\_count}.
#+end_export
#+begin_src go <<Test methods, Pa. \ref{pa:tdb}>>=
  //<<Test access to \ty{taxon}, Pa. \ref{pa:tdb}>>
  //<<Test access to \ty{genome}, Pa. \ref{pa:tdb}>>
  //<<Test access to \ty{genome\_count}, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_export latex
We test the seven methods that access \ty{taxon}, \ty{Name},
\ty{CommonName}, \ty{Rank}, \ty{Parent}, \ty{Children}, \ty{Subtree},
\ty{MRCA}, and \ty{NumTaxa}, \ty{Taxids}, and \ty{CommonTaxids}.
#+end_export
#+begin_src go <<Test access to \ty{taxon}, Pa. \ref{pa:tdb}>>=
  //<<Test \ty{Name}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{CommonName}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{Rank}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{Parent}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{Children}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{Subtree}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{MRCA}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{NumTaxa}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{Taxids}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{CommonTaxids}, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  We look up the name of taxon, 9606, \emph{Homo sapiens}.
#+end_src
#+begin_src go <<Test \ty{Name}, Pa. \ref{pa:tdb}>>=
  tid := 9606
  get, _ := taxdb.Name(tid)
  want := "Homo sapiens"
  if get != want {
	  t.Errorf("get: %q; want: %q", get, want)
  }
#+end_src
#+begin_export latex
The common name of \emph{Homo sapiens} is human.
#+end_export
#+begin_src go <<Test \ty{CommonName}, Pa. \ref{pa:tdb}>>=
  get, _ = taxdb.CommonName(tid)
  want = "human"
  if get != want {
	  t.Errorf("get common_name: %s; want: %s\n",
		  get, want)
  }
#+end_src
#+begin_export latex
The rank of \emph{Homo sapiens} is ``species''.
#+end_export
#+begin_src go <<Test \ty{Rank}, Pa. \ref{pa:tdb}>>=
  get, _ = taxdb.Rank(tid)
  want = "species"
  if get != want {
	  t.Errorf("get rank: %s; want: %s\n", get, want)
  }
#+end_src
#+begin_src latex
  The parent of \emph{Homo sapiens} is \emph{Homo} with taxon-ID
  9605.
#+end_src
#+begin_src go <<Test \ty{Parent}, Pa. \ref{pa:tdb}>>=
  g, _ := taxdb.Parent(tid)
  w := 9605
  if g != w {
	  t.Errorf("get parent: %d; want: %d", g, w)
  }
#+end_src
#+begin_src latex
  \emph{Homo sapiens} (9606) has two children.
#+end_src
#+begin_src go <<Test \ty{Children}, Pa. \ref{pa:tdb}>>=
  children, _ := taxdb.Children(tid)
  g = len(children)
  w = 2
  if g != w {
	  t.Errorf("get %d children; want %d", g, w)
  }
#+end_src
#+begin_src latex
  The \emph{Hominidae} subtree contains 26 nodes.
#+end_src
#+begin_src go <<Test \ty{Subtree}, Pa. \ref{pa:tdb}>>=
  tid = 207598
  taxa, _ := taxdb.Subtree(tid)
  g = len(taxa)
  w = 26
  if g != w {
	  t.Errorf("get %d nodes in subtree; want %d", g, w)
  }
#+end_src
#+begin_src latex
  To test \ty{MRCA}, we construct several tests and run them in a loop.
#+end_src
#+begin_src go <<Test \ty{MRCA}, Pa. \ref{pa:tdb}>>=
  //<<Construct tests of \ty{MRCA}, Pa. \ref{pa:tdb}>>
  //<<Run tests of \ty{MRCA}, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  We look for the MRCAs of the following five sets of taxa in the tree
  shown in Figure~\ref{fig:hom}:
  \begin{itemize}
  \item $\{46359\}$
  \item $\{46359, 1159185\}$
  \item $\{46359, 406788\}$
  \item $\{37011, 9597\}$
  \item $\{37011, 9597, 46359\}$
  \end{itemize}
#+end_src
#+begin_src go <<Construct tests of \ty{MRCA}, Pa. \ref{pa:tdb}>>=
  targets := make([][]int, 0)
  var res []int
  targets = append(targets, []int{46359})
  res = append(res, 46359)
  targets = append(targets, []int{46359, 1159185})
  res = append(res, 499232)
  targets = append(targets, []int{46359, 406788})
  res = append(res, 9592)
  targets = append(targets, []int{37011, 9597})
  res = append(res, 9596)
  targets = append(targets, []int{37011, 9597, 46359})
  res = append(res, 207598)
#+end_src
#+begin_src latex
  We loop over the tests.
#+end_src
#+begin_src go <<Run tests of \ty{MRCA}, Pa. \ref{pa:tdb}>>=
  for i, target := range targets {
	  get,_ := taxdb.MRCA(target)	  
	  want := res[i]
	  if get != want {
		  t.Errorf("get: %d\nwant: %d\n", get, want)
	  }
  }
#+end_src
#+begin_export latex
Our test database contains 33 taxa, we test whether \ty{NumTaxa}
returns that number.
#+end_export
#+begin_src go <<Test \ty{NumTaxa}, Pa. \ref{pa:tdb}>>=
  g, _ = taxdb.NumTaxa()
  w = 33
  if g != w {
	  t.Errorf("get:\n%d\nwant:\n%d\n", g, w)
  }
#+end_src
#+begin_src latex
  To test \ty{Taxids}, we get the four taxa whose names contain
  \emph{homo sapiens}, but limit the output to the last two. Notice the
  lower-case ``h'' in \emph{homo}, which SQL matches to the upper-case
  ``H'' in the actual names.
#+end_src
#+begin_src go <<Test \ty{Taxids}, Pa. \ref{pa:tdb}>>=
  taxa, _ = taxdb.Taxids("%homo sapiens%", 2, 2)
  g = len(taxa)
  w = 2
  if g != w {
	  t.Errorf("get %d taxa for homo sapiens; want %d",
		  g, w)
  }
#+end_src
#+begin_export latex
To test \ty{CommonTaxids}, we get the two accession where the common
name contains ``man'', ``human'' and ``Heidelberg man''.
#+end_export
#+begin_src go <<Test \ty{CommonTaxids}, Pa. \ref{pa:tdb}>>=
  taxa, _ = taxdb.CommonTaxids("%man%", -1, 0)
  g = len(taxa)
  w = 2
  if g != w {
	  t.Errorf("get %d taxa for man; want %d",
		  g, w)
  }
#+end_src
#+begin_export latex
We test four Methods that access \ty{genome}, \ty{Accessions},
\ty{Level}, and \ty{FilterAccessions}.
#+end_export
#+begin_src go <<Test access to \ty{genome}, Pa. \ref{pa:tdb}>>=
  //<<Test \ty{Accessions}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{Level}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{FilterAccessions}, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_export latex
\emph{Homo sapiens} has 1851 accessions in the database, so we check
whether \ty{Accessions} returns this number of accessions.
#+end_export
#+begin_src go <<Test \ty{Accessions}, Pa. \ref{pa:tdb}>>=
  tid = 9606
  arr, _ := taxdb.Accessions(tid)
  g = len(arr)
  w = 1851
  if g != w {
	  t.Errorf("get:\n%d\nwant:\n%d\n", g, w)
  }
#+end_src
#+begin_src latex
  The level of accession \ty{GCA\_049640585.1} is \ty{contig}.
#+end_src
#+begin_src go <<Test \ty{Level}, Pa. \ref{pa:tdb}>>=
  acc := "GCA_049640585.1"
  get, _ = taxdb.Level(acc)
  want = "contig"
  if want != get {
	  t.Errorf("get: %s\nwant: %s\n", get, want)
  }
#+end_src
#+begin_src latex
  To test \ty{FilterAccessisons}, we generate a slice of three
  accessions, GCA\_000002115.2, GCA\_000004845.2, and GCA\_000181135.1,
  which have the levels chromosome, scaffold, and contig, respectively.
  Then we filter with one, two, three, and four levels.
#+end_src
#+begin_src go <<Test \ty{FilterAccessions}, Pa. \ref{pa:tdb}>>=
  accessions := []string{
	  "GCA_000002115.2",
	  "GCA_000004845.2",
	  "GCA_000181135.1"}
  //<<Filter with one level, Pa. \ref{pa:util}>>
  //<<Filter with two levels, Pa. \ref{pa:util}>>
  //<<Filter with three levels, Pa. \ref{pa:util}>>
  //<<Filter with four levels, Pa. \ref{pa:util}>>
#+end_src
#+begin_src latex
  We filter with the top level, ``complete'', and expect to get zero
  accessions back.
#+end_src
#+begin_src go <<Filter with one level, Pa. \ref{pa:util}>>=
  levels := make(map[string]bool)
  levels["complete"] = true
  filteredAcc, _ := taxdb.FilterAccessions(accessions, levels)
  if len(filteredAcc) != 0 {
	  t.Errorf("want 0 accessions, get %d\n", len(filteredAcc))
  }
#+end_src
#+begin_src latex
  We filter with level ``complete'' and ``chromosome'', so we expect to
  get the first accession back.
#+end_src
#+begin_src go <<Filter with two levels, Pa. \ref{pa:util}>>=
  levels["chromosome"] = true
  filteredAcc, _ = taxdb.FilterAccessions(accessions, levels)
  if len(filteredAcc) != 1 {
	  t.Errorf("want 1 accession, get %d\n", len(filteredAcc))
  }
  if accessions[0] != filteredAcc[0] {
	  t.Errorf("want:\n%s\nget:\n%s\n",
		  accessions[0],
		  filteredAcc[0])
  }
#+end_src
#+begin_src latex
  We add a third level, ``scaffold'', and expect to get the first two
  accessions back.
#+end_src
#+begin_src go <<Filter with three levels, Pa. \ref{pa:util}>>=
  levels["scaffold"] = true
  filteredAcc, _ = taxdb.FilterAccessions(accessions, levels)
  if len(filteredAcc) != 2 {
	  t.Errorf("want 2 accessions, get %d\n", len(filteredAcc))
  }
  for i, a := range filteredAcc {
	  if accessions[i] != a {
		  t.Errorf("want:\n%s\nget:\n%s\n",
			  accessions[i],
			  a)
	  }
  }
#+end_src
#+begin_src latex
  We add the fourth and last level, ``contig'', and expect to get all
  three accessions back.
#+end_src
#+begin_src go <<Filter with four levels, Pa. \ref{pa:util}>>=
  levels["contig"] = true
  filteredAcc, _ = taxdb.FilterAccessions(accessions, levels)
  for i, accession := range accessions {
	  if filteredAcc[i] != accession {
		  t.Errorf("want:\n%s\nget:\n%s\n",
			  accession,
			  filteredAcc[i])
	  }
  }
#+end_src
#+begin_export latex
We test two functions that access \ty{genome\_count}, \ty{NumGenomes}
and \ty{NumGenomesRec}.
#+end_export
#+begin_src go <<Test access to \ty{genome\_count}, Pa. \ref{pa:tdb}>>=
  //<<Test \ty{NumGenomes}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{NumGenomesRec}, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_export latex
The test database contains 58 complete genomes for \emph{Homo sapiens}
and we test whether \ty{NumGenomes} returns that.
#+end_export
#+begin_src go <<Test \ty{NumGenomes}, Pa. \ref{pa:tdb}>>=
  tid = 9606
  g, _ = taxdb.NumGenomes(tid, "complete")
  w = 58
  if g != w {
	  t.Errorf("get:\n%d\nwant:\n%d\n", g, w)
  }
#+end_src
#+begin_export latex
The 58 complete genomes for \emph{Homo sapiens} are the only complete
genomes among the \emph{Homininae} subfamily, which has taxon-ID
207598. So we test whether \ty{NumGenomesRec} returns 58 complete
genomes for \emph{Homininae}.
#+end_export
#+begin_src go <<Test \ty{NumGenomesRec}, Pa. \ref{pa:tdb}>>=
  tid = 207598
  g, _ = taxdb.NumGenomesRec(207598, "complete")
  w = 58
  if g != 58 {
	  t.Errorf("get:\n%d\nwant:\n%d\n", g, w)
  }
#+end_src
#+begin_export latex
Across the four assembly levels, we expect to find 1888 genomes in
\emph{Homininae}.
#+end_export
#+begin_src go <<Test \ty{NumGenomesRec}, Pa. \ref{pa:tdb}>>=
  g, _ = taxdb.NumGenomesRec(tid, "complete")
  x, _ := taxdb.NumGenomesRec(tid, "chromosome")
  g += x
  x, _ = taxdb.NumGenomesRec(tid, "scaffold")
  g += x
  x, _ = taxdb.NumGenomesRec(tid, "contig")
  g +=x
  w = 1888
  if g != w {
	  t.Errorf("get:\n%d\nwant:\n%d\n", g, w)
  }
#+end_src
