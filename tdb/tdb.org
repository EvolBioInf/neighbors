#+begin_src latex
  \section{\ty{tdb}}
  ! Package tdb constructs and queries the taxonomy database.

  Figure~\ref{fig:db} shows the ER diagram of the taxonomy database,
  which consists of two tables, taxon and genome. The outline of
  \ty{tdb} has hooks for imports, types, methods, and functions. It also
  has a hook for a special kind of package variable, the templates for
  SQL queries.  \bpa{tdb}{pa:tdb}
#+end_src
#+begin_src go <<tdb.go>>=
  package tdb

  import (
	  //<<Imports, Pa. \ref{pa:tdb}>>
  )
  //<<Types, Pa. \ref{pa:tdb}>>
  //<<Methods, Pa. \ref{pa:tdb}>>
  //<<Functions, Pa. \ref{pa:tdb}>>
  //<<Query templates, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  \epa The package \ty{tdb} has two central types: \ty{TaxonDB} wraps
  the relational database shown in Figure~\ref{fig:db} and \ty{Taxonomy}
  is the taxonomic tree.
#+end_src
#+begin_src go <<Types, Pa. \ref{pa:tdb}>>=
  type TaxonomyDB struct {
	  db *sql.DB
  }
#+end_src
#+begin_src latex
  We import \ty{sql}. In addition, we import a driver for \ty{sqlite3},
  \ty{go-sqlite3}, using a blank import.
#+end_src
#+begin_src go <<Imports, Pa. \ref{pa:tdb}>>=
  "database/sql"
  _ "github.com/mattn/go-sqlite3"
#+end_src
#+begin_src latex
  \subsection{\ty{NewTaxonomyDB}}
  ! The function \ty{NewTaxonomyDB} takes as parameters the names of the
  ! four input files from which we construct the database, and the name of
  ! the database. It opens these files, opens a new database, and
  ! constructs the database.
#+end_src
#+begin_src go <<Functions, Pa. \ref{pa:tdb}>>=
  func NewTaxonomyDB(nodes, names, genbank,
	  refseq, dbName string) {
	  //<<Open files, Pa. \ref{pa:tdb}>>
	  //<<Open database, Pa. \ref{pa:tdb}>>
	  //<<Construct database, Pa. \ref{pa:tdb}>>
  }
#+end_src
#+begin_src latex
  We open the four input tables and defer their closure.
#+end_src
#+begin_src go <<Open files, Pa. \ref{pa:tdb}>>=
  of := util.Open(nodes)
  defer of.Close()
  af := util.Open(names)
  defer af.Close()
  gf := util.Open(genbank)
  defer gf.Close()
  rf := util.Open(refseq)
  defer rf.Close()
#+end_src
#+begin_src latex
  We import \ty{util}.
#+end_src
#+begin_src go <<Imports, Pa. \ref{pa:tdb}>>=
  "github.com/evolbioinf/neighbors/util"
#+end_src
#+begin_src latex
  Before opening the database, we check whether it already exists. Then
  we open it. If that fails, we abort. We also make sure the database is
  eventually closed again.
#+end_src
#+begin_src go <<Open database, Pa. \ref{pa:tdb}>>=
  //<<Does database exist? Pa. \ref{pa:tdb}>>
  db, err := sql.Open("sqlite3", dbName)
  util.Check(err)
  defer db.Close()
#+end_src
#+begin_src latex
  If we are asked to build a new database on top of an existing one, the
  user has probably made a mistake, so we bow out.
#+end_src
#+begin_src go <<Does database exist? Pa. \ref{pa:tdb}>>=
  _, err := os.Stat(dbName)
  if err == nil {
	  fmt.Fprintf(os.Stderr, "database %s already exists\n",
		  dbName)
	  os.Exit(1)
  }
#+end_src
#+begin_src latex
  We import \ty{fmt}.
#+end_src
#+begin_src go <<Imports, Pa. \ref{pa:tdb}>>=
  "os"
  "fmt"
#+end_src
#+begin_src latex
  To construct the database, we construct the input tables, and load
  their counterparts in the database.
#+end_src
#+begin_src go <<Construct database, Pa. \ref{pa:tdb}>>=
  //<<Construct tables, Pa. \ref{pa:tdb}>>
  //<<Load tables, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  As illustrated in Figure~\ref{fig:db}, we construct two tables,
  \ty{taxon} and \ty{genome}.
#+end_src
#+begin_src go <<Construct tables, Pa. \ref{pa:tdb}>>=
  //<<Construct table \ty{taxon}, Pa. \ref{pa:tdb}>>
  //<<Construct table \ty{genome}, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  Table \ty{taxon} has the four attributes \ty{taxid}, \ty{parent},
  \ty{name}, and \ty{rank}. Taxon-IDs are integers, names are
  text. \ty{taxid} is also the primary key. As there are currently 2.7
  million taxa, and this number is bound to grow, we ensure that queries
  are quick by using indexes. The primary key, \ty{taxid}, is
  automatically indexed and we construct an index for \ty{parent}. We
  might be tempted to also index the remaining two attributes, \ty{name}
  and \ty{rank}. However, these are text and \ty{sqlite} does not make
  use of indexes on text columns. You can check this on an existing
  database by prefacing a query with \ty{explain query plan}. So we
  leave it at our index for \ty{parent}.
#+end_src
#+begin_src go <<Construct table \ty{taxon}, Pa. \ref{pa:tdb}>>=
  sqlStmt := `create table taxon (
  taxid int, parent int, name text, rank text,
  primary key(taxid));
  create index taxon_parent_idx on taxon(parent);`
  if _, err := db.Exec(sqlStmt); err != nil {
	  log.Fatal(err)
  }
#+end_src
#+begin_src latex
  We import \ty{log}.
#+end_src
#+begin_src go <<Imports, Pa. \ref{pa:tdb}>>=
  "log"
#+end_src
#+begin_src latex
  Table \ty{genome} has the four attributes \ty{taxid}, \ty{size},
  \ty{accession}, and an assembly \ty{level}. An accession is unique, so
  it also serves as primary key. The size is given in bp, but we store
  it as Mb, so its type is float. To stress that every genome belongs to
  exactly one taxon, we declare \ty{taxid} as foreign key into
  \ty{taxon}. We also index the numerical attributes \ty{taxid} and
  \ty{size}.
#+end_src
#+begin_src go <<Construct table \ty{genome}, Pa. \ref{pa:tdb}>>=
  sqlStmt = `create table genome (
  taxid int, size real, 
	 accession text, level text,
  primary key(accession),
  foreign key(taxid) references taxon(taxid));
  create index genome_taxid_idx on genome(taxid);
  create index genome_size_idx on genome(size);`
  if _, err := db.Exec(sqlStmt); err != nil {
	  log.Fatal(err)
  }
#+end_src
#+begin_src latex
  Since \ty{genome} has a foreign key referring to \ty{taxon}, we load
  \ty{taxon} before \ty{genome}.
#+end_src
#+begin_src go <<Load tables, Pa. \ref{pa:tdb}>>=
  //<<Load table \ty{taxon}, Pa. \ref{pa:tdb}>>
  //<<Load table \ty{genome}, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex 
  To load \ty{taxon}, we simulate a join of \ty{nodes.dmp} and
  \ty{names.dmp} on taxon-ID. For this we create the type \ty{taxon}
  with the same four fields as the four attributes in
  Figure~\ref{fig:db}.
#+end_src
#+begin_src go <<Types, Pa. \ref{pa:tdb}>>=
  type taxon struct {
	  taxid, parent int
	  name, rank string
  }
#+end_src
#+begin_src latex
  We read the taxa into a map and insert them into the table \ty{taxon}.
#+end_src
#+begin_src go <<Load table \ty{taxon}, Pa. \ref{pa:tdb}>>=
  taxa := make(map[int]*taxon)
  //<<Read taxa, Pa. \ref{pa:tdb}>>
  //<<Insert taxa, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  To read the taxa, we first parse the nodes file, then the names file.
#+end_src
#+begin_src go <<Read taxa, Pa. \ref{pa:tdb}>>=
  //<<Parse nodes file, Pa. \ref{pa:tdb}>>
  //<<Parse names file, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  We traverse the nodes file using a scanner. The first column contains
  the taxon-ID, the second the parent's ID, the third the taxon's
  rank. Columns are delimited by \verb+\t|\t+ and we convert the strings
  denoting IDs to integers before storing them.
#+end_src
#+begin_src go <<Parse nodes file, Pa. \ref{pa:tdb}>>=
  scanner := bufio.NewScanner(of)
  for scanner.Scan() {
	  row := scanner.Text()
	  fields := strings.SplitN(row, "\t|\t", 4)
	  t := new(taxon)
	  t.taxid, err = strconv.Atoi(fields[0])
	  if err != nil { log.Fatal(err) }
	  t.parent, err = strconv.Atoi(fields[1])
	  if err != nil { log.Fatal(err) }
	  t.rank = fields[2]
	  taxa[t.taxid] = t
  }
#+end_src
#+begin_src latex
  We import \ty{bufio}, \ty{strings}, and \ty{strconv}.
#+end_src
#+begin_src go <<Imports, Pa. \ref{pa:tdb}>>=
  "bufio"
  "strings"
  "strconv"
#+end_src
#+begin_src latex
  We are done with the nodes file and close it.
#+end_src
#+begin_src go <<Close files, Pa. \ref{pa:tdb}>>=
  of.Close()
#+end_src
#+begin_src latex
  The names file contains the taxon-ID in the first column and the name
  in the second. Now, there are several kinds of names, scientific,
  common, and more. We only store the scientific names. To parse the
  file, we again use a scanner and split the columns at \verb+\t|\t+.
#+end_src
#+begin_src go <<Parse names file, Pa. \ref{pa:tdb}>>=
  scanner = bufio.NewScanner(af)
  for scanner.Scan() {
	  row := scanner.Text()
	  fields := strings.Split(row, "\t|\t")
	  id, err := strconv.Atoi(fields[0])
	  if err != nil { log.Fatal(err) }
	  if fields[3][:3] == "sci" {
		  taxa[id].name = fields[1]
	  }
  }
#+end_src
#+begin_src latex
  We are done with the names file and close it.
#+end_src
#+begin_src go <<Close files, Pa. \ref{pa:tdb}>>=
  af.Close()
#+end_src
#+begin_src latex
  Having read the taxa from the input files, we insert them in the
  \ty{taxon} table. We do this with a transaction, which takes a
  statement and prepares it, before we insert the individual rows.
#+end_src
#+begin_src go <<Insert taxa, Pa. \ref{pa:tdb}>>=
  tx, err := db.Begin()
  if err != nil { log.Fatal(err) }
  sqlStmt = "insert into taxon(taxid, parent, name, rank) " +
	  "values(?, ?, ?, ?)"
  stmt, err := tx.Prepare(sqlStmt)
  if err != nil { log.Fatal(err) }
  //<<Insert rows into table \ty{taxon}, Pa. \ref{pa:tdb}>>
  tx.Commit()
  stmt.Close()
#+end_src
#+begin_src latex
  Each entry in the \ty{taxa} map corresponds to a row in the table.
#+end_src
#+begin_src go <<Insert rows into table \ty{taxon}, Pa. \ref{pa:tdb}>>=
  for _, v := range taxa {
	  _, err = stmt.Exec(v.taxid, v.parent, v.name, v.rank)
	  if err != nil { log.Fatal(err) }
  }
#+end_src
#+begin_src latex
  The next table to load is \ty{genome}. Like the taxa, we read the
  genomes from input and insert them.
#+end_src
#+begin_src go <<Load table \ty{genome}, Pa. \ref{pa:tdb}>>=
  //<<Read genomes, Pa. \ref{pa:tdb}>>
  //<<Insert genomes, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  We read each genome into a struct that holds the four attributes shown
  in Figure~\ref{fig:db}, \ty{taxid}, \ty{accession}, \ty{level}, and
  \ty{size} in Mb. In addition, we declare a switch to indicate whether
  or not the genome has been written to table.
#+end_src
#+begin_src go <<Types, Pa. \ref{pa:tdb}>>=
  type genome struct {
	  taxid int
	  accession, level string
	  size float64
	  written bool
  }
#+end_src
#+begin_src latex
  With a handful of exceptions, the refseq genomes are a subset of the
  genbank genomes. However, the refseq genomes are often better
  annotated. For example, the current version of the human genome has
  genbank accession \ty{GCA\_000001405.29} and refseq accession
  \ty{GCF\_000001405.40}. As you can see, the two accessions have an
  identical central core, but are distinguished by their prefix and
  suffix. They also have distinct annotations. In our example, the
  refseq genome has a total gene count of 59,715, while the genbank
  genome has a total gene count of only 37. So wherever there's a refseq
  genome \emph{and} a genbank genome, as shown by the identical core of
  their accessions, we pick the refseq genome. We also need to take care
  of the handful of refseq genomes not contained in genbank.

  To accomplish this, we store the refseq genomes in a map with the core
  accession as key and the genome as value. Then we construct a
  transaction for inserting the genomes into the database and actually
  insert them.
#+end_src
#+begin_src go <<Read genomes, Pa. \ref{pa:tdb}>>=
  rsGenomes := make(map[string]*genome)
  //<<Store refseq genomes, Pa. \ref{pa:tdb}>>
  //<<Construct transaction for inserting genomes, Pa. \ref{pa:tdb}>>
  //<<Insert genomes, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  To store the refseq genomes, we parse the refseq file with a buffered
  scanner. Each row that is not a comment is split into its constituent
  fields. The first field is the accession, which we reduce to its core
  by calling the function \ty{coreAcc}, which we still need to
  write. The genome is constructed by calling \ty{fields2genome}, which
  we also still need to write. Then we insert the genome into the map as
  value to the core accession.
#+end_src
#+begin_src go <<Store refseq genomes, Pa. \ref{pa:tdb}>>=
  scanner = bufio.NewScanner(rf)
  for scanner.Scan() {
	  row := scanner.Text()
	  if row[0] == '#' {
		  continue
	  }
	  fields := strings.Split(row, "\t")
	  k := coreAcc(fields[0])
	  g := fields2genome(fields)
	  rsGenomes[k] = g
  }
#+end_src
#+begin_src latex
  In function \ty{coreAcc} we take an accession of the form
  \begin{verbatim}
  pref_core.num
  \end{verbatim}
  and return \ty{core}.
#+end_src
#+begin_src go <<Functions, Pa. \ref{pa:tdb}>>=
  func coreAcc(acc string) string {
	  s := strings.Index(acc, "_") + 1
	  e := strings.Index(acc, ".")
	  core := acc[s:e]
	  return core
  }
#+end_src
#+begin_export latex
\begin{table}
  \caption{The 38 columns in the table of genome accessions supplied
    by the NCBI.}\label{tab:pg}
  \begin{center}
    \begin{tabular}{rlrlrl}
      \hline
      \input{../tdb/acc}\\
      \hline
    \end{tabular}
  \end{center}
\end{table}
In function \ty{fields2genome} we take one row in the accession file
and return a genome. A genome consists of an accession, a taxon ID, an
assembly level, and a size.
#+end_export
#+begin_src go <<Functions, Pa. \ref{pa:tdb}>>=
  func fields2genome(fields []string) *genome {
	  g := new(genome)
	  //<<Set accession, Pa. \ref{pa:tdb}>>
	  //<<Set taxon ID, Pa. \ref{pa:tdb}>>
	  //<<Set assembly level, Pa. \ref{pa:tdb}>>
	  //<<Set size, Pa. \ref{pa:tdb}>>
	  return g
  }
#+end_src
#+begin_src latex
  As shown in Table~\ref{tab:pg}, the accession is in the first column.
#+end_src
#+begin_src go <<Set accession, Pa. \ref{pa:tdb}>>=
  g.accession = fields[0]
#+end_src
#+begin_src latex
  The taxon ID is in the sixth column and we convert it from its string
  representation to integer.
#+end_src
#+begin_src go <<Set taxon ID, Pa. \ref{pa:tdb}>>=
  id, err := strconv.Atoi(fields[5])
  util.Check(err)
  g.taxid = id
#+end_src
#+begin_src latex
  The assembly level in the 12th column and has values ``Complete
  Genome'', ``Chromosome'', ``Scaffold'', or ``Contig''. We store these
  values as lower case and slightly abbreviated to ``complete'',
  ``chromosome'', ``scaffold'', or ``contig''.
#+end_src
#+begin_src go <<Set assembly level, Pa. \ref{pa:tdb}>>=
  g.level = fields[11]
  g.level = strings.Fields(g.level)[0]
  g.level = strings.ToLower(g.level)
#+end_src
#+begin_src latex
  The size is in the 26th column. It is given in bp, which we convert to
  Mb.
#+end_src
#+begin_src go <<Set size, Pa. \ref{pa:tdb}>>=
  si, err := strconv.Atoi(fields[25])
  util.Check(err)
  g.size = float64(si) / 1000000.0
#+end_src
#+begin_src latex
  To insert the genomes into the \ty{genome} table, we use a transaction
  like we did for the \ty{taxon} table.
#+end_src
#+begin_src go <<Construct transaction for inserting genomes, Pa. \ref{pa:tdb}>>=
  tx, err = db.Begin()
  util.Check(err)
  sqlStmt = "insert into genome(accession, " +
	  "taxid, level, size) " +
	  "values(?, ?, ?, ?)"
  stmt, err = tx.Prepare(sqlStmt)
  util.Check(err)
  defer tx.Commit()
  defer stmt.Close()
#+end_src
#+begin_src latex
  To insert the genomes, we iterate over the genbank accessions. We
  extract the data fields, lookup or construct the genome for the
  corresponding accession, and insert the genome. Then we insert the
  refseq genomes that haven't been inserted yet. There should only be
  very few, if any, such left-over refseq genomes.
#+end_src
#+begin_src go <<Insert genomes, Pa. \ref{pa:tdb}>>=
  scanner = bufio.NewScanner(gf)
  for scanner.Scan() {
	  //<<Extract data fields, Pa. \ref{pa:tdb}>>
	  //<<Lookup or construct genome, Pa. \ref{pa:tdb}>>
	  //<<Insert genome, Pa. \ref{pa:tdb}>>
  }
  //<<Insert left-over refseq genomes, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  Unless it is a comment, we split the row of data into its constituent
  fields.
#+end_src
#+begin_src go <<Extract data fields, Pa. \ref{pa:tdb}>>=
  row := scanner.Text()
  if row[0] == '#' {
	  continue
  }
  fields := strings.Split(row, "\t")
#+end_src
#+begin_src latex
  Whenever we can look up a refseq equivalent, we store that in the
  table, and note that this genome is going to be written to
  table. Otherwise we construct the genbank genome.
#+end_src
#+begin_src go <<Lookup or construct genome, Pa. \ref{pa:tdb}>>=
  ca := coreAcc(fields[0])
  var g *genome
  if _, ok := rsGenomes[ca]; ok {
	  g = rsGenomes[ca]
	  rsGenomes[ca].written = true
  } else {
	  g = fields2genome(fields)
  }
#+end_src
#+begin_src latex
  We insert the genome---refseq or genbank---by executing the prepared
  statement.
#+end_src
#+begin_src go <<Insert genome, Pa. \ref{pa:tdb}>>=
  _, err = stmt.Exec(g.accession, g.taxid,
	  g.level, g.size)
  util.Check(err)
#+end_src
#+begin_src latex
  As our last step in constructing the \ty{genome} table, we iterate
  over the refseq genomes and insert the ones that haven't been written
  yet.
#+end_src
#+begin_src go <<Insert left-over refseq genomes, Pa. \ref{pa:tdb}>>=
  for _, g := range rsGenomes {
	  if g.written {
		  continue
	  }
	  _, err = stmt.Exec(g.accession, g.taxid,
		  g.level, g.size)
  }
#+end_src
#+begin_src latex
  \subsection{\ty{OpenTaxonomyDB}}
  ! The function \ty{OpenTaxonomyDB} opens an existing taxonomy database
  ! and returns a pointer to it.
#+end_src
#+begin_src go <<Functions, Pa. \ref{pa:tdb}>>=
  func OpenTaxonomyDB(name string) *TaxonomyDB {
	  db := new(TaxonomyDB)
	  var err error
	  db.db, err = sql.Open("sqlite3", name)
	  if err != nil { log.Fatal(err) }
	  return db
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Close}}
  ! The method \ty{Close} closes a taxonomy database.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Close() {
	  t.db.Close()
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Accessions}}
  !The method \ty{Accessions} takes as parameter a taxon-ID and returns
  !a slice accessions of genome assemblies belonging to that taxon and
  !an error.

  We query for accessions and then store them in the global string slice
  we return.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Accessions(taxon int) ([]string, error) {
	  var err error
	  accessions := make([]string, 0)
	  //<<Query for accessions, Pa. \ref{pa:tdb}>>
	  //<<Store accessions, Pa. \ref{pa:tdb}>>
	  return accessions, err
  }
#+end_src
#+begin_src latex
  We begin querying by defining a template for querying accessions.
#+end_src
#+begin_src go <<Query templates, Pa. \ref{pa:tdb}>>= 
  var accessionT = "select accession " +
	  "from genome " +
	  "where taxid=%d"
#+end_src
#+begin_export latex
We construct the query for accessions from our template and run it. We
make sure that the input stream returned is eventually closed again
and check the error returned by the database.
#+end_export
#+begin_src go <<Query for accessions, Pa. \ref{pa:tdb}>>=
  q := fmt.Sprintf(accessionT, taxon)
  rows, err := t.db.Query(q)
  defer rows.Close()
  if err != nil {
	  return nil, err
  }
#+end_src
#+begin_src latex
  We append each accession to our slice of accessions.
#+end_src
#+begin_src go <<Store accessions, Pa. \ref{pa:tdb}>>=
  accession := ""
  for rows.Next() {
	  err := rows.Scan(&accession)
	  if err != nil {
		  return nil, err
	  }
	  accessions = append(accessions, accession)
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Name}}
  ! The method \ty{Name} takes as argument a taxon ID and returns the
  ! taxon's name and an error.

  We construct the query, execute it, and extract the name.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Name(taxon int) (string, error) {
	  var err error
	  name := ""
	  //<<Construct name query, Pa. \ref{pa:tdb}>>
	  //<<Execute name query, Pa. \ref{pa:tdb}>>
	  //<<Extract name, Pa. \ref{pa:tdb}>>
	  return name, err
  }
#+end_src
#+begin_src latex
  To construct the name query, we define a template.
#+end_src
#+begin_src go <<Query templates, Pa. \ref{pa:tdb}>>=
  var nameT = "select name from taxon where taxid=%d"
#+end_src
#+begin_src latex
  We construct the query from our new template.
#+end_src
#+begin_src go <<Construct name query, Pa. \ref{pa:tdb}>>=
  q := fmt.Sprintf(nameT, taxon)
#+end_src
#+begin_src latex
  We execute the query, which might throw an error. We also close the
  results table once we're done with it.
#+end_src
#+begin_src go <<Execute name query, Pa. \ref{pa:tdb}>>=
  rows, err := t.db.Query(q)
  defer rows.Close()
  if err != nil {
	  return "", err
  }
#+end_src
#+begin_src latex
  Our results table contains only the requested single name. We scan
  this and catch potential errors.
#+end_src
#+begin_src go <<Extract name, Pa. \ref{pa:tdb}>>=
  rows.Next()
  err = rows.Scan(&name)
  if err != nil {
	  return "", err
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Rank}}
  !The method \ty{Rank} takes as argument a taxon ID and returns the
  !taxon's rank and an error.

  We construct the query, execute it, and extract the rank.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Rank(taxon int) (string, error) {
	  var err error
	  rank := ""
	  //<<Construct rank query, Pa. \ref{pa:tdb}>>
	  //<<Execute rank query, Pa. \ref{pa:tdb}>>
	  //<<Extract rank, Pa. \ref{pa:tdb}>>
	  return rank, err
  }
#+end_src
#+begin_src latex
  To construct the rank query, we first define a template.
#+end_src
#+begin_src go <<Query templates, Pa. \ref{pa:tdb}>>=
  var rankT = "select rank from taxon where taxid=%d"
#+end_src
#+begin_src latex
  We construct the rank query from its template.
#+end_src
#+begin_src go <<Construct rank query, Pa. \ref{pa:tdb}>>=
  q := fmt.Sprintf(rankT, taxon)
#+end_src
#+begin_src latex
  We execute the rank query, which might throw an error. We also close
  the results table once we're done with it.
#+end_src
#+begin_src go <<Execute rank query, Pa. \ref{pa:tdb}>>=
  rows, err := t.db.Query(q)
  defer rows.Close()
  if err != nil {
	  return "", err
  }
#+end_src
#+begin_src latex
  Our results table contains only the requested single rank. We scan
  this and catch potential errors.
#+end_src
#+begin_src go <<Extract rank, Pa. \ref{pa:tdb}>>=
  rows.Next()
  err = rows.Scan(&rank)
  if err != nil {
	  return "", err
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Parent}}
  ! The method \ty{Parent} takes as argument a taxon ID and returns the
  ! taxon ID of its parent and an error.

  We construct the query, execute it, and extract the parent.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Parent(c int) (int, error) {
	  var err error
	  parent := 0
	  //<<Construct parent query, Pa. \ref{pa:tdb}>>
	  //<<Execute parent query, Pa. \ref{pa:tdb}>>
	  //<<Extract parent, Pa. \ref{pa:tdb}>>
	  return parent, err
  }
#+end_src
#+begin_src latex
  We define the template for the parent query.
#+end_src
#+begin_src go <<Query templates, Pa. \ref{pa:tdb}>>=
  var parentT = "select parent from taxon where taxid=%d"
#+end_src
#+begin_src latex
  We construct the parent query from its query.
#+end_src
#+begin_src go <<Construct parent query, Pa. \ref{pa:tdb}>>=
  q := fmt.Sprintf(parentT, c)
#+end_src
#+begin_src latex
  We execute the query to get the results table. Query execution might
  throw an error, which we catch. We also make sure the results table is
  eventually closed again.
#+end_src
#+begin_src go <<Execute parent query, Pa. \ref{pa:tdb}>>=
  rows, err := t.db.Query(q)
  defer rows.Close()
  if err != nil {
	  return 0, err
  }
#+end_src
#+begin_src latex
  Our results table contains at most one row with one entry, the
  parent. We extract this and catch possible errors.
#+end_src
#+begin_src go <<Extract parent, Pa. \ref{pa:tdb}>>=
  rows.Next()
  err = rows.Scan(&parent)
  if err != nil {
	  return 0, err
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Children}}
  ! The method \ty{Children} takes as argument a taxon ID and returns its
  ! children and an error.

  We construct the children query, execute it, and extract the children.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Children(p int) ([]int, error) {
	  var err error
	  children := make([]int, 0)
	  //<<Construct children query, Pa. \ref{pa:tdb}>>
	  //<<Execute children query, Pa. \ref{pa:tdb}>>
	  //<<Extract children, Pa. \ref{pa:tdb}>>
	  return children, err
  }
#+end_src
#+begin_src latex
  We define a template for the children query.
#+end_src
#+begin_src go <<Query templates, Pa. \ref{pa:tdb}>>=
  var childrenT = "select taxid from taxon where parent=%d"
#+end_src
#+begin_src latex
  We construct the children query from its template and the parent
  passed.
#+end_src
#+begin_src go <<Construct children query, Pa. \ref{pa:tdb}>>=
  q := fmt.Sprintf(childrenT, p)
#+end_src
#+begin_src latex
  We execute the children query to get the results table, catch errors,
  and eventually close the results table again.
#+end_src
#+begin_src go <<Execute children query, Pa. \ref{pa:tdb}>>=
  rows, err := t.db.Query(q)
  defer rows.Close()
  if err != nil {
	  return nil, err
  }
#+end_src
#+begin_src latex
  We copy the children into the slice we've prepared for this purpose.
#+end_src
#+begin_src go <<Extract children, Pa. \ref{pa:tdb}>>=
  child := 0
  for rows.Next() {
	  err = rows.Scan(&child)
	  if err != nil {
		  return nil, err
	  }
	  children = append(children, child)
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Subtree}}
  ! The method \ty{Subtree} returns all taxa in a subtree, including its
  ! root, and an error.

  It looks up the taxa in the subtree by calling the private function
  \ty{traverseSubtree}.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Subtree(r int) ([]int, error) {
	  var err error
	  taxa := make([]int, 0)
	  taxa, err = traverseSubtree(t, r, taxa)
	  if err != nil {
		  return nil, err
	  }
	  return taxa, err
  }
#+end_src
#+begin_src latex
  In \ty{traverseSubtree} we append the incoming node to the slice
  of taxa and iterate over the node's children.
#+end_src
#+begin_src go <<Functions, Pa. \ref{pa:tdb}>>=
  func traverseSubtree(t *TaxonomyDB, v int, taxa []int) ([]int, error) {
	  taxa = append(taxa, v)
	  children, err := t.Children(v)
	  if err != nil {
		  return nil, err
	  }
	  //<<Iterate over children, Pa. \ref{pa:tdb}>>
	  return taxa, err
  }
#+end_src
#+begin_export latex
We iterate over the children and call \ty{traverseSubtree} on each of
them, unless it is identical to the parent, which would give us an
infinite loop.
#+end_export
#+begin_src go <<Iterate over children, Pa. \ref{pa:tdb}>>=
  for _, child := range children {
	  if child != v {
		  taxa, err = traverseSubtree(t, child, taxa)
		  if err != nil {
			  return nil, err
		  }
	  }
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Taxids}}
  ! \ty{Taxids} matches the name of a taxon and returns the
  ! corresponding taxon-IDs and an error.

  We construct and execute the query for taxon-IDs, extract the IDs, and
  return them.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Taxids(name string) ([]int, error) {
	  var err error
	  taxids := make([]int, 0)
	  //<<Construct taxids query, Pa. \ref{pa:tdb}>>
	  //<<Execute taxids query, Pa. \ref{pa:tdb}>>
	  //<<Extract taxids, Pa. \ref{pa:tdb}>>
	  return taxids, err
  }
#+end_src
#+begin_src latex
  We declare a template for the taxids query.
#+end_src
#+begin_src go <<Query templates, Pa. \ref{pa:tdb}>>=
  var taxidsT = "select taxid from taxon where name like '%s'"
#+end_src
#+begin_src latex
  We construct the query for taxon-IDs from its template.
#+end_src
#+begin_src go <<Construct taxids query, Pa. \ref{pa:tdb}>>=
  q := fmt.Sprintf(taxidsT, name)
#+end_src
#+begin_src latex
  We execute the query for taxon-IDs and catch potential errors. We also
  make sure the result table is eventually closed again.
#+end_src
#+begin_src go <<Execute taxids query, Pa. \ref{pa:tdb}>>=
  rows, err := t.db.Query(q)
  defer rows.Close()
  if err != nil {
	  return nil, err
  }
#+end_src
#+begin_src latex
  We extract and store the taxon-IDs.
#+end_src
#+begin_src go <<Extract taxids, Pa. \ref{pa:tdb}>>=
  taxid := 0
  for rows.Next() {
	  err = rows.Scan(&taxid)
	  if err != nil {
		  return nil, err
	  }
	  taxids = append(taxids, taxid)
  }
#+end_src
#+begin_src latex
  \subsection{\ty{MRCA}}
  !The method \ty{MRCA} takes as input a slice of taxon IDs and returns
  !their most recent common ancestor and an error.

  For example, in Figure~\ref{fig:tax}, the most recent common ancestor
  of taxa 4 and 7 is 3. We begin by checking the IDs supplied and then
  search for the MRCA. If we haven't found one, we return -1.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) MRCA(ids []int) (int, error) {
	  var err error
	  mrca := -1
	  //<<Check IDs, Pa. \ref{pa:tdb}>>
	  //<<Search for MRCA, Pa. \ref{pa:tdb}>>
	  return mrca, err
  }
#+end_src
#+begin_src latex
If the ID list is empty, something went wrong and we throw an
error. If the ID list contains a single entry, that is the MRCA.
#+end_src
#+begin_src go <<Check IDs, Pa. \ref{pa:tdb}>>=
  if len(ids) == 0 {
	  m := "Empty ID list in tdb.MRCA"
	  return 0, errors.New(m)
  } else if len(ids) == 1 {
	  return ids[0], nil
  }
#+end_src
#+begin_export latex
We import \ty{errors}.
#+end_export
#+begin_src go <<Imports, Pa. \ref{pa:tdb}>>=
  "errors"
#+end_src
#+begin_src latex
There is a rich history of MRCA queries in computer
science~\cite[ch. 3]{ohl13:bio}. However, instead of using the general
solution to the problem, I construct a simpler solution that involves
climbing to the common ancestor of a set of taxa. If these taxa are
closely related, the climb is short.

To be more precise, in each step of our climb, we increment a
descendant counter for each node. If one of these counters is equal to
the number of input taxa, the corresponding node is the
MRCA. Otherwise, we climb to the parents and repeat. So we construct a
variable to count descendants and variables for parents and
children. Then we iterate over the parents.
#+end_src
#+begin_src go <<Search for MRCA, Pa. \ref{pa:tdb}>>=
  //<<Construct counter for descendants, Pa. \ref{pa:tdb}>>
  //<<Construct variables for parents and children, Pa. \ref{pa:tdb}>>
  //<<Iterate over parents, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
We store descendants in a map between a taxon ID, which is an integer,
and the number of its descendants, another integer. The initial number
of descendants of the taxa supplied is one.
#+end_src
#+begin_src go <<Construct counter for descendants, Pa. \ref{pa:tdb}>>=
  desc := make(map[int]int)
  for _, id := range ids {
	  desc[id] = 1
  }
#+end_src
#+begin_src latex
We store the parent and child taxa as integer slices. The children
slice is initialized to the taxon IDs supplied.
#+end_src
#+begin_src go <<Construct variables for parents and children, Pa. \ref{pa:tdb}>>=
  parents := make([]int, 0)
  children := make([]int, 0)
  for _, id := range ids {
	  children = append(children, id)
  }
#+end_src
#+begin_src latex
  As long as we have more than one child, i. e. haven't reached the root
  yet, we climb to the next set of parents and replace the children by
  the parents.
#+end_src
#+begin_src go <<Iterate over parents, Pa. \ref{pa:tdb}>>=
  for len(children) > 1 {
	  //<<Climb to parents, Pa. \ref{pa:tdb}>>
	  //<<Replace parents by children, Pa. \ref{pa:tdb}>>
  }
#+end_src
#+begin_src latex
  For each parent we reach, we check whether the number of its
  descendants is greater or equal to the number of taxa submitted. If
  yes, we've found the MRCA and return it.
#+end_src
#+begin_src go <<Climb to parents, Pa. \ref{pa:tdb}>>=
  for _, child := range children {
	  parent, err := t.Parent(child)
	  if err != nil {
		  return 0, err
	  }
	  desc[parent] += desc[child]
	  if desc[parent] >= len(ids) {
		  mrca = parent
		  break
	  }
	  parents = append(parents, parent)
  }
#+end_src
#+begin_src latex
If the MRCA hasn't been found yet, we replace the children by the
parent and reset the parent slice to empty.
#+end_src
#+begin_src go <<Replace parents by children, Pa. \ref{pa:tdb}>>=
  if mrca == -1 {
	  children = children[:0]
	  for _, parent := range parents {
		  children = append(children, parent)
	  }
	  parents = parents[:0]
  } else {
	  break
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Level}}
  ! The method \ty{Level} takes as argument a genome accession and
  ! returns the assembly level and an eror.

  We construct the level query, execute it, and extract the level before
  we return it.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (t *TaxonomyDB) Level(acc string) (string, error) {
	  var err error
	  level := ""
	  //<<Construct level query, Pa. \ref{pa:tdb}>>
	  //<<Execute level query, Pa. \ref{pa:tdb}>>
	  //<<Extract level, Pa. \ref{pa:tdb}>>
	  return level, err
  }
#+end_src
#+begin_src latex
  We define a template for the level query.
#+end_src
#+begin_src go <<Query templates, Pa. \ref{pa:tdb}>>=
  var levelT = "select level from genome where accession='%s'"
#+end_src
#+begin_src latex
  We construct the level query from its template.
#+end_src
#+begin_src go <<Construct level query, Pa. \ref{pa:tdb}>>=
  q := fmt.Sprintf(levelT, acc)
#+end_src
#+begin_src latex
  We execute the level query, check the error, and make sure the result
  stream we just opened is eventually closed again.
#+end_src
#+begin_src go <<Execute level query, Pa. \ref{pa:tdb}>>=
  rows, err := t.db.Query(q)
  defer rows.Close()
  if err != nil {
	  return "", err
  }
#+end_src
#+begin_src latex
  We scan the first row in the table and check the error returned.
#+end_src
#+begin_src go <<Extract level, Pa. \ref{pa:tdb}>>=
  rows.Next()
  err = rows.Scan(&level)
  if err != nil {
	  return "", err
  }
#+end_src
#+begin_src latex
  \subsection{\ty{FilterAccessions}}
  ! \ty{FilterAccessions} takes as input a slice of genome accessions
  ! and a list of desired assembly levels. It then removes any accession
  ! that doesn't conform to one of the levels supplied and returns the
  ! adjusted slice of genome accessions and an error. The input
  ! accessions remain unchanged.
#+end_src
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (d *TaxonomyDB) FilterAccessions(acc []string,
	  levels map[string]bool) ([]string, error) {
	  newAcc := []string{}
	  var err error
	  //<<Remove accessions with wrong level, Pa. \ref{pa:tdb}>>
	  return newAcc, err
  }
#+end_src
#+begin_src latex
  For each of the genome accessions supplied, we look up the assembly
  level. If the level conforms to one of the desired levels, we store
  the accession in a new slice of accessions, which we return at the
  end.
#+end_src
#+begin_src go <<Remove accessions with wrong level, Pa. \ref{pa:tdb}>>=
  for _, a := range acc {
	  level, err := d.Level(a)
	  if err != nil {
		  return nil, err
	  }
	  if levels[level] {
		  newAcc = append(newAcc, a)
	  }
  }
#+end_src
#+begin_export latex
\subsection{\ty{NumTaxa}}
! The method \ty{NumTaxa} returns the number of taxa in the database
! and an error.

We construct the query for the number of taxa, execute it, and extract
the result.
#+end_export
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (d *TaxonomyDB) NumTaxa() (int, error) {
	  n := 0
	  var err error
	  //<<Construct numtax query, Pa. \ref{pa:tdb}>>
	  //<<Execute numtax query, Pa. \ref{pa:tdb}>>
	  //<<Extract numtax, Pa. \ref{pa:tdb}>>
	  return n, err
  }
#+end_src
#+begin_export latex
The query for the number of taxa is a single line of SQL.
#+end_export
#+begin_src go <<Construct numtax query, Pa. \ref{pa:tdb}>>=
  q := "select count(*) from taxon"
#+end_src
#+begin_export latex
We execute our query, store the table row returned, and check the
error.
#+end_export
#+begin_src go <<Execute numtax query, Pa. \ref{pa:tdb}>>=
  row, err := d.db.Query(q)
  defer row.Close()
  if err != nil {
	  return 0, err
  }
#+end_src
#+begin_export latex
We extract the number of taxa from the table row and check the error.
#+end_export
#+begin_src go <<Extract numtax, Pa. \ref{pa:tdb}>>=
  row.Next()
  err = row.Scan(&n)
  if err != nil {
	  return 0, err
  }
#+end_src
#+begin_export latex
\subsection{\ty{NumGenomes}}
! The method \ty{NumGenomes} returns the number of genomes in the
! database and an error.

We construc the query for the number of genomes, execute it, and
extract the result.
#+end_export
#+begin_src go <<Methods, Pa. \ref{pa:tdb}>>=
  func (d *TaxonomyDB) NumGenomes() (int, error) {
	  n := 0
	  var err error
	  //<<Construct numgen query, Pa. \ref{pa:tdb}>>
	  //<<Execute numgen query, Pa. \ref{pa:tdb}>>
	  //<<Extract numgen, Pa. \ref{pa:tdb}>>
	  return n, err
  }
#+end_src
#+begin_export latex
The query for the number of genomes is a simple \ty{count} statement.
#+end_export
#+begin_src go <<Construct numgen query, Pa. \ref{pa:tdb}>>=
  q := "select count(*) from genome"
#+end_src
#+begin_export latex
We execute the query, store the table row returned, and check the
error.
#+end_export
#+begin_src go <<Execute numgen query, Pa. \ref{pa:tdb}>>=
  row, err := d.db.Query(q)
  defer row.Close()
  if err != nil {
	  return 0, err
  }
#+end_src
#+begin_export latex
We extract the number of genomes from the table row and check the
error.
#+end_export
#+begin_src go <<Extract numgen, Pa. \ref{pa:tdb}>>=
  row.Next()
  err = row.Scan(&n)
  if err != nil {
	  return 0, err
  }
#+end_src
#+begin_src latex
  \subsection{Testing}
  We test on the \emph{Homininae} subfamily shown in
  Figure~\ref{fig:hom}.
  \begin{figure}
    \begin{center}
      \scalebox{0.4}{\includegraphics{../tdb/hom}}
    \end{center}
    \caption{Taxonomy of the \emph{Homininae} subfamily; colored nodes
      contain genomes.}\label{fig:hom}
  \end{figure}
  The outline of our code for testing \ty{tdb} has a hook for the
  testing logic.
#+end_src
#+begin_src go <<tdb_test.go>>=
  package tdb

  import (
	  "testing"
  )

  func TestTdb(t *testing.T) {
	  //<<Testing, Pa. \ref{pa:tdb}>>
  }
#+end_src
#+begin_src latex
  We test the function \ty{NewTaxonomyDB}, and the eight methods
  \ty{Name}, \ty{Rank}, \ty{Parent}, \ty{Children}, \ty{Subtree},
  \ty{Taxids}, \ty{MRCA}, \ty{Level}, and \ty{FilterAccessions}.
#+end_src
#+begin_src go <<Testing, Pa. \ref{pa:tdb}>>=
  //<<Test \ty{NewTaxonomyDB}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{Name}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{Rank}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{Parent}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{Children}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{Subtree}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{Taxids}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{MRCA}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{Level}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{FilterAccessions}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{NumTaxa}, Pa. \ref{pa:tdb}>>
  //<<Test \ty{NumGenomes}, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  We build a small database, \ty{taxSmall.db}.
#+end_src
#+begin_src go <<Test \ty{NewTaxonomyDB}, Pa. \ref{pa:tdb}>>=
  p := "../data/"
  no := p + "nodesTest.dmp"
  na := p + "namesTest.dmp"
  gb := p + "gbTest.txt"
  rs := p + "rsTest.txt"
  db := p + "taxSmall.db"
  NewTaxonomyDB(no, na, gb, rs, db)
#+end_src
#+begin_src latex
  We extract the full taxonomy from the small database and check it has
  26 entries.
#+end_src
#+begin_src go <<Test \ty{NewTaxonomyDB}, Pa. \ref{pa:tdb}>>=
  taxdb := OpenTaxonomyDB(db)
  subtree, _ := taxdb.Subtree(207598)
  if len(subtree) != 26 {
	  t.Errorf("get %d rows, want 26", len(subtree))
	  for _, s := range subtree {
		  println(s)
	  }
  }
#+end_src
#+begin_src latex
  We look up the name of taxon, 9606, \emph{Homo sapiens}.
#+end_src
#+begin_src go <<Test \ty{Name}, Pa. \ref{pa:tdb}>>=
  tid := 9606
  get, _ := taxdb.Name(tid)
  want := "Homo sapiens"
  if get != want {
	  t.Errorf("get: %q; want: %q", get, want)
  }
#+end_src
#+begin_export latex
The rank of \emph{Homo sapiens} is ``species''.
#+end_export
#+begin_src go <<Test \ty{Rank}, Pa. \ref{pa:tdb}>>=
  get, _ = taxdb.Rank(tid)
  want = "species"
  if get != want {
	  t.Errorf("get rank: %s; want: %s\n", get, want)
  }
#+end_src
#+begin_src latex
  The parent of \emph{Homo sapiens} is \emph{Homo} with taxon-ID
  9605.
#+end_src
#+begin_src go <<Test \ty{Parent}, Pa. \ref{pa:tdb}>>=
  g, _ := taxdb.Parent(tid)
  w := 9605
  if g != w {
	  t.Errorf("get parent: %d; want: %d", g, w)
  }
#+end_src
#+begin_src latex
  \emph{Homo sapiens} (9606) has two children.
#+end_src
#+begin_src go <<Test \ty{Children}, Pa. \ref{pa:tdb}>>=
  children, _ := taxdb.Children(tid)
  g = len(children)
  w = 2
  if g != w {
	  t.Errorf("get %d children; want %d", g, w)
  }
#+end_src
#+begin_src latex
  The \emph{Hominidae} subtree contains 26 nodes.
#+end_src
#+begin_src go <<Test \ty{Subtree}, Pa. \ref{pa:tdb}>>=
  tid = 207598
  taxa, _ := taxdb.Subtree(tid)
  g = len(taxa)
  w = 26
  if g != w {
	  t.Errorf("get %d nodes in subtree; want %d", g, w)
  }
#+end_src
#+begin_src latex
  To test \ty{Taxids}, we get the four taxa whose names contain
  \emph{homo sapiens}. Notice the lower-case ``h'' in \emph{homo}, which
  SQL matches to the upper-case ``H'' in the actual names.
#+end_src
#+begin_src go <<Test \ty{Taxids}, Pa. \ref{pa:tdb}>>=
  taxa, _ = taxdb.Taxids("%homo sapiens%")
  g = len(taxa)
  w = 4
  if g != w {
	  t.Errorf("get %d taxa for homo sapiens; want %d",
		  g, w)
  }
#+end_src
#+begin_src latex
  To test \ty{MRCA}, we construct several tests and run them in a loop.
#+end_src
#+begin_src go <<Test \ty{MRCA}, Pa. \ref{pa:tdb}>>=
  //<<Construct tests of \ty{MRCA}, Pa. \ref{pa:tdb}>>
  //<<Run tests of \ty{MRCA}, Pa. \ref{pa:tdb}>>
#+end_src
#+begin_src latex
  We look for the MRCAs of the following five sets of taxa in the tree
  shown in Figure~\ref{fig:hom}:
  \begin{itemize}
  \item $\{46359\}$
  \item $\{46359, 1159185\}$
  \item $\{46359, 406788\}$
  \item $\{37011, 9597\}$
  \item $\{37011, 9597, 46359\}$
  \end{itemize}
#+end_src
#+begin_src go <<Construct tests of \ty{MRCA}, Pa. \ref{pa:tdb}>>=
  targets := make([][]int, 0)
  var res []int
  targets = append(targets, []int{46359})
  res = append(res, 46359)
  targets = append(targets, []int{46359, 1159185})
  res = append(res, 499232)
  targets = append(targets, []int{46359, 406788})
  res = append(res, 9592)
  targets = append(targets, []int{37011, 9597})
  res = append(res, 9596)
  targets = append(targets, []int{37011, 9597, 46359})
  res = append(res, 207598)
#+end_src
#+begin_src latex
  We loop over the tests.
#+end_src
#+begin_src go <<Run tests of \ty{MRCA}, Pa. \ref{pa:tdb}>>=
  for i, target := range targets {
	  get,_ := taxdb.MRCA(target)	  
	  want := res[i]
	  if get != want {
		  t.Errorf("get: %d\nwant: %d\n", get, want)
	  }
  }
#+end_src
#+begin_src latex
  The level of accession \ty{GCA\_049640585.1} is \ty{contig}.
#+end_src
#+begin_src go <<Test \ty{Level}, Pa. \ref{pa:tdb}>>=
  acc := "GCA_049640585.1"
  get, _ = taxdb.Level(acc)
  want = "contig"
  if want != get {
	  t.Errorf("get: %s\nwant: %s\n", get, want)
  }
#+end_src
#+begin_src latex
  To test \ty{FilterAccessisons}, we generate a slice of three
  accessions, GCA\_000002115.2, GCA\_000004845.2, and GCA\_000181135.1,
  which have the levels chromosome, scaffold, and contig, respectively.
  Then we filter with one, two, three, and four levels.
#+end_src
#+begin_src go <<Test \ty{FilterAccessions}, Pa. \ref{pa:tdb}>>=
  accessions := []string{
	  "GCA_000002115.2",
	  "GCA_000004845.2",
	  "GCA_000181135.1"}
  //<<Filter with one level, Pa. \ref{pa:util}>>
  //<<Filter with two levels, Pa. \ref{pa:util}>>
  //<<Filter with three levels, Pa. \ref{pa:util}>>
  //<<Filter with four levels, Pa. \ref{pa:util}>>
#+end_src
#+begin_src latex
  We filter with the top level, ``complete'', and expect to get zero
  accessions back.
#+end_src
#+begin_src go <<Filter with one level, Pa. \ref{pa:util}>>=
  levels := make(map[string]bool)
  levels["complete"] = true
  filteredAcc, _ := taxdb.FilterAccessions(accessions, levels)
  if len(filteredAcc) != 0 {
	  t.Errorf("want 0 accessions, get %d\n", len(filteredAcc))
  }
#+end_src
#+begin_src latex
  We filter with level ``complete'' and ``chromosome'', so we expect to
  get the first accession back.
#+end_src
#+begin_src go <<Filter with two levels, Pa. \ref{pa:util}>>=
  levels["chromosome"] = true
  filteredAcc, _ = taxdb.FilterAccessions(accessions, levels)
  if len(filteredAcc) != 1 {
	  t.Errorf("want 1 accession, get %d\n", len(filteredAcc))
  }
  if accessions[0] != filteredAcc[0] {
	  t.Errorf("want:\n%s\nget:\n%s\n",
		  accessions[0],
		  filteredAcc[0])
  }
#+end_src
#+begin_src latex
  We add a third level, ``scaffold'', and expect to get the first two
  accessions back.
#+end_src
#+begin_src go <<Filter with three levels, Pa. \ref{pa:util}>>=
  levels["scaffold"] = true
  filteredAcc, _ = taxdb.FilterAccessions(accessions, levels)
  if len(filteredAcc) != 2 {
	  t.Errorf("want 2 accessions, get %d\n", len(filteredAcc))
  }
  for i, a := range filteredAcc {
	  if accessions[i] != a {
		  t.Errorf("want:\n%s\nget:\n%s\n",
			  accessions[i],
			  a)
	  }
  }
#+end_src
#+begin_src latex
  We add the fourth and last level, ``contig'', and expect to get all
  three accessions back.
#+end_src
#+begin_src go <<Filter with four levels, Pa. \ref{pa:util}>>=
  levels["contig"] = true
  filteredAcc, _ = taxdb.FilterAccessions(accessions, levels)
  for i, accession := range accessions {
	  if filteredAcc[i] != accession {
		  t.Errorf("want:\n%s\nget:\n%s\n",
			  accession,
			  filteredAcc[i])
	  }
  }
#+end_src
#+begin_export latex
Our test database contains 33 taxa, we test whether \ty{NumTaxa}
returns that number.
#+end_export
#+begin_src go <<Test \ty{NumTaxa}, Pa. \ref{pa:tdb}>>=
  g, _ = taxdb.NumTaxa()
  w = 33
  if g != w {
	  t.Errorf("get:\n%d\nwant:\n%d\n", g, w)
  }
#+end_src
#+begin_export latex
The test database contains 1919 genomes and we test whether
\ty{NumGenomes} returns that.
#+end_export
#+begin_src go <<Test \ty{NumGenomes}, Pa. \ref{pa:tdb}>>=
  g, _ = taxdb.NumGenomes()
  w = 1919
  if g != w {
	  t.Errorf("get:\n%d\nwant:\n%d\n", g, w)
  }
#+end_src

