#+begin_src latex
  \section{\ty{tdb}}
  The package \ty{tdb} provides code for constructing and navigating
  \ty{taxonDb} (Figure~\ref{fig:db}). Its outline has hooks for imports,
  types, methods, and functions.
  \bpa{tdb}{pa:tdb}
#+end_src
#+begin_src go <<tdb.go>>=
  // Package tdb constructs and queries the taxonomy database.
  package tdb

  import (
	  //<<Imports, Pa.~\ref{pa:tdb}>>
  )
  //<<Types, Pa.~\ref{pa:tdb}>>
  //<<Methods, Pa.~\ref{pa:tdb}>>
  //<<Functions, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  \epa
  The central type of \ty{tdb} is \ty{TaxonDB}, which wraps a database
  defined in the standard library.
#+end_src
#+begin_src go <<Types, Pa.~\ref{pa:tdb}>>=
  type TaxonomyDB struct {
	  db *sql.DB
  }
#+end_src
#+begin_src latex
  We import \ty{sql}. In addition, we import a driver for \ty{sqlite3},
  \ty{go-sqlite3}, using a blank import.
#+end_src
#+begin_src go <<Imports, Pa.~\ref{pa:tdb}>>=
  "database/sql"
  _ "github.com/mattn/go-sqlite3"
#+end_src
#+begin_src latex
  \subsection{\ty{NewTaxonomyDB}}
  The function \ty{NewTaxonomyDB} takes as parameters the names of the
  five input files and the name of the database. It opens these files,
  opens a new database, constructs the database, closes the files, and
  closes the database.
#+end_src
#+begin_src go <<Functions, Pa.~\ref{pa:tdb}>>=
  // NewTaxonomyDB takes as parameters the names of the five data files
  // and the database name, and constructs the database from them.
  func NewTaxonomyDB(nodes, names, prokaryotes,
	  eukaryotes, viruses, dbName string) {
	  //<<Open files, Pa.~\ref{pa:tdb}>>
	  //<<Open database, Pa.~\ref{pa:tdb}>>
	  //<<Construct database, Pa.~\ref{pa:tdb}>>
	  //<<Close database, Pa.~\ref{pa:tdb}>>
	  //<<Close files, Pa.~\ref{pa:tdb}>>
  }
#+end_src
#+begin_src latex
  We open the five input tables.
#+end_src
#+begin_src go <<Open files, Pa.~\ref{pa:tdb}>>=
  of := util.Open(nodes)
  af := util.Open(names)
  pf := util.Open(prokaryotes)
  ef := util.Open(eukaryotes)
  vf := util.Open(viruses)
#+end_src
#+begin_src latex
  We import \ty{util}.
#+end_src
#+begin_src go <<Imports, Pa.~\ref{pa:tdb}>>=
  "github.com/evolbioinf/neighbors/util"
#+end_src
#+begin_src latex
  Before opening the database, we check whether it already exists. If we
  cannot open the database, we abort.
#+end_src
#+begin_src go <<Open database, Pa.~\ref{pa:tdb}>>=
  //<<Does database exist? Pa.~\ref{pa:tdb}>>
  db, err := sql.Open("sqlite3", dbName)
  if err != nil { log.Fatal(err) }
#+end_src
#+begin_src latex
  We import \ty{log}.
#+end_src
#+begin_src go <<Imports, Pa.~\ref{pa:tdb}>>=
  "log"
#+end_src
#+begin_src latex
  If we are asked to build a new database on top of an existing one, the
  user has probably made a mistake, so we bow out.
#+end_src
#+begin_src go <<Does database exist? Pa.~\ref{pa:tdb}>>=
  _, err := os.Stat(dbName)
  if err == nil {
	  fmt.Fprintf(os.Stderr, "database %s already exists\n",
		  dbName)
	  os.Exit(1)
  }
#+end_src
#+begin_src latex
  We import \ty{os} and \ty{fmt}.
#+end_src
#+begin_src go <<Imports, Pa.~\ref{pa:tdb}>>=
  "os"
  "fmt"
#+end_src
#+begin_src latex
  To construct the database, we construct the input tables, and load
  their counterparts in the database.
#+end_src
#+begin_src go <<Construct database, Pa.~\ref{pa:tdb}>>=
  //<<Construct tables, Pa.~\ref{pa:tdb}>>
  //<<Load tables, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  As illustrated in Figure~\ref{fig:db}, we construct two tables,
  \ty{taxon} and \ty{genome}.
#+end_src
#+begin_src go <<Construct tables, Pa.~\ref{pa:tdb}>>=
  //<<Construct table \ty{taxon}, Pa.~\ref{pa:tdb}>>
  //<<Construct table \ty{genome}, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  Table \ty{taxon} has the attributes \ty{taxid}, \ty{parent}, and
  \ty{name}. Taxon-IDs are integers, names are text. Taxon-IDs also
  functions as primary key. As there are currently over two million
  taxa, we index all three attributes to ensure quick queries.
#+end_src
#+begin_src go <<Construct table \ty{taxon}, Pa.~\ref{pa:tdb}>>=
  sqlStmt := `create table taxon (
  taxid int, parent int, name text, primary key(taxid));
  create index taxon_taxid_idx on taxon(taxid);
  create index taxon_parent_idx on taxon(parent);
  create index taxon_name_idx on taxon(name);
  `
  if _, err := db.Exec(sqlStmt); err != nil {
	  log.Fatal(err)
  }
#+end_src
#+begin_src latex
  Table \ty{genome} has attributes \ty{taxid}, \ty{size}, and
  \ty{replicons}. To stress that every genome belongs to exactly one
  taxon, we declare \ty{taxid} as foreign key into \ty{taxon}. We also
  index the taxon-ID.
#+end_src
#+begin_src go <<Construct table \ty{genome}, Pa.~\ref{pa:tdb}>>=
  sqlStmt = `create table genome (
  taxid int, size real, replicons text,
  foreign key(taxid) references taxon(taxid));
  create index genome_taxid_idx on genome(taxid);
  `
  if _, err := db.Exec(sqlStmt); err != nil {
	  log.Fatal(err)
  }
#+end_src
#+begin_src latex
  Since \ty{genome} has a foreign key referring to \ty{taxon}, we load
  \ty{taxon} before \ty{genome}.
#+end_src
#+begin_src go <<Load tables, Pa.~\ref{pa:tdb}>>=
  //<<Load table \ty{taxon}, Pa.~\ref{pa:tdb}>>
  //<<Load table \ty{genome}, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex 
  To load \ty{taxon}, we simulate a join of \ty{nodes.dmp} and
  \ty{names.dmp} on taxon-ID. For this we create the type \ty{taxon}
  with the same three fields as the three attributes in
  Figure~\ref{fig:db}.
#+end_src
#+begin_src go <<Types, Pa.~\ref{pa:tdb}>>=
  type taxon struct {
	  taxid, parent int
	  name string
  }
#+end_src
#+begin_src latex
  We read the taxa into a map and insert them into the table \ty{taxon}.
#+end_src
#+begin_src go <<Load table \ty{taxon}, Pa.~\ref{pa:tdb}>>=
  taxa := make(map[int]*taxon)
  //<<Read taxa, Pa.~\ref{pa:tdb}>>
  //<<Insert taxa, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  To read the taxa, we first parse the nodes file, then the names file.
#+end_src
#+begin_src go <<Read taxa, Pa.~\ref{pa:tdb}>>=
  //<<Parse nodes file, Pa.~\ref{pa:tdb}>>
  //<<Parse names file, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  We traverse the nodes file using a scanner. The first column contains
  the taxon-ID, the second the parent's ID. Columns are delimited by
  \verb+\t|\t+ and we convert the strings denoting IDs to integers
  before storing them.
#+end_src
#+begin_src go <<Parse nodes file, Pa.~\ref{pa:tdb}>>=
  scanner := bufio.NewScanner(of)
  for scanner.Scan() {
	  row := scanner.Text()
	  fields := strings.SplitN(row, "\t|\t", 3)
	  t := new(taxon)
	  t.taxid, err = strconv.Atoi(fields[0])
	  if err != nil { log.Fatal(err) }
	  t.parent, err = strconv.Atoi(fields[1])
	  if err != nil { log.Fatal(err) }
	  taxa[t.taxid] = t
  }
#+end_src
#+begin_src latex
  We import \ty{bufio}, \ty{strings}, and \ty{strconv}.
#+end_src
#+begin_src go <<Imports, Pa.~\ref{pa:tdb}>>=
  "bufio"
  "strings"
  "strconv"
#+end_src
#+begin_src latex
  We are done with the nodes file and close it.
#+end_src
#+begin_src go <<Close files, Pa.~\ref{pa:tdb}>>=
  of.Close()
#+end_src
#+begin_src latex
  The names file contains the taxon-ID in the first column and the name
  in the second. Now, there are several kinds of names, scientific,
  common, and more. We store the scientific names. To parse the file, we
  again use a scanner and split the columns at \verb+\t|\t+.
#+end_src
#+begin_src go <<Parse names file, Pa.~\ref{pa:tdb}>>=
  scanner = bufio.NewScanner(af)
  for scanner.Scan() {
	  row := scanner.Text()
	  fields := strings.Split(row, "\t|\t")
	  id, err := strconv.Atoi(fields[0])
	  if err != nil { log.Fatal(err) }
	  if fields[3][:3] == "sci" {
		  taxa[id].name = fields[1]
	  }
  }
#+end_src
#+begin_src latex
  We are done with the names file and close it.
#+end_src
#+begin_src go <<Close files, Pa.~\ref{pa:tdb}>>=
  af.Close()
#+end_src
#+begin_src latex
  Having read the taxa from the input files, we insert them in the
  \ty{taxon} table. We do this with a transaction, which takes a
  statement and prepares it, before we insert the individual rows into
  \ty{taxon}.
#+end_src
#+begin_src go <<Insert taxa, Pa.~\ref{pa:tdb}>>=
  tx, err := db.Begin()
  if err != nil { log.Fatal(err) }
  sqlStmt = "insert into taxon(taxid, parent, name) " +
	  "values(?, ?, ?)"
  stmt, err := tx.Prepare(sqlStmt)
  if err != nil { log.Fatal(err) }
  //<<Insert rows into table \ty{taxon}, Pa.~\ref{pa:tdb}>>
  tx.Commit()
  stmt.Close()
#+end_src
#+begin_src latex
  Each entry in the \ty{taxa} map corresponds to a row in the table.
#+end_src
#+begin_src go <<Insert rows into table \ty{taxon}, Pa.~\ref{pa:tdb}>>=
  for _, v := range taxa {
	  _, err = stmt.Exec(v.taxid, v.parent, v.name)
	  if err != nil { log.Fatal(err) }
  }
#+end_src
#+begin_src latex
  The next table to load is \ty{genome}. So we also read the genomes
  from input and insert them.
#+end_src
#+begin_src go <<Load table \ty{genome}, Pa.~\ref{pa:tdb}>>=
  //<<Read genomes, Pa.~\ref{pa:tdb}>>
  //<<Insert genomes, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  We read each genome into a struct that holds the three attributes
  shown in Figure~\ref{fig:db}, \ty{taxid}, \ty{replicons}, and
  \ty{size}.
#+end_src
#+begin_src go <<Types, Pa.~\ref{pa:tdb}>>=
  type genome struct {
	  taxid int
	  replicons string
	  size float64
  }
#+end_src
#+begin_src latex
  We save genomes in a slice and read them from the three files that
  correspond to three deep divisions of life, prokaryotes, eukaryotes,
  and viruses.
#+end_src
#+begin_src go <<Read genomes, Pa.~\ref{pa:tdb}>>=
  var genomes []genome
  //<<Read prokaryote genomes, Pa.~\ref{pa:tdb}>>
  //<<Read eukaryote genomes, Pa.~\ref{pa:tdb}>>
  //<<Read virus genomes, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  In the prokaryote genomes file, we skip the header, split the columns
  at tabs, generate the genomes and save them.
#+end_src
#+begin_src go <<Read prokaryote genomes, Pa.~\ref{pa:tdb}>>=
  fn := pf.Name()
  scanner = bufio.NewScanner(pf)
  var gen genome
  for scanner.Scan() {
	  row := scanner.Text()
	  if row[0] == '#' { continue }
	  fields := strings.Split(row, "\t")
	  //<<Generate a genome, Pa.~\ref{pa:tdb}>>
	  genomes = append(genomes, gen)
  }
#+end_src
#+begin_src latex
  In an individual row, the second column contains the taxon-ID, the
  seventh the size in Mb, and the nineth the replicons. Unfortunately,
  it is possible that no genome size is given, in which case we set it
  to -1. It is also possible that the row is incomplete, in which case
  we skip it and send a warning.
#+end_src
#+begin_src go <<Generate a genome, Pa.~\ref{pa:tdb}>>=
  if len(fields) < 9 {
	  fmt.Fprintf(os.Stderr,
		  "skipping truncated line in %q\n", fn)
	  continue
  }
  gen.taxid, err = strconv.Atoi(fields[1])
  if err != nil { log.Fatal(err) }
  gen.size, err = strconv.ParseFloat(fields[6], 64)
  if err != nil { gen.size = -1.0 }
  gen.replicons = fields[8]
#+end_src
#+begin_src latex
  We close the prokaryote genomes file.
#+end_src
#+begin_src go <<Close files, Pa.~\ref{pa:tdb}>>=
  pf.Close()
#+end_src
#+begin_src latex
  Similarly, we read the file for the eukaryote genomes, which has the
  same structure as that of the prokaryotes.
#+end_src
#+begin_src go <<Read eukaryote genomes, Pa.~\ref{pa:tdb}>>=
  fn = ef.Name()
  scanner = bufio.NewScanner(ef)
  for scanner.Scan() {
	  row := scanner.Text()
	  if row[0] == '#' { continue }
	  fields := strings.Split(row, "\t")
	  //<<Generate a genome, Pa.~\ref{pa:tdb}>>
	  genomes = append(genomes, gen)
  }
#+end_src
#+begin_src latex
  We close the eukaryote genomes file.
#+end_src
#+begin_src go <<Close files, Pa.~\ref{pa:tdb}>>=
  ef.Close()
#+end_src
#+begin_src latex
  We scan the file of viral genomes.
#+end_src
#+begin_src go <<Read virus genomes, Pa.~\ref{pa:tdb}>>=
  fn = vf.Name()
  scanner = bufio.NewScanner(vf)
  for scanner.Scan() {
	  row := scanner.Text()
	  if row[0] == '#' { continue }
	  fields := strings.Split(row, "\t")
	  //<<Generate a viral genome, Pa.~\ref{pa:tdb}>>
	  genomes = append(genomes, gen)
  }
#+end_src
#+begin_src latex
  The file describing the genomes of viruses has a slightly different
  structure from that of prokaryotes and eukaryotes. Replicons are now
  in the tenth column, and genome size is given in kb. We convert that
  to Mb to have all genome lengths on the same scale. Again, if a line
  is incomplete, we skip it with message.
#+end_src
#+begin_src go <<Generate a viral genome, Pa.~\ref{pa:tdb}>>=
  if len(fields) < 10 {
	  fmt.Fprintf(os.Stderr,
		  "skipping truncated line in %q", fn)
	  continue
  }
  gen.taxid, err = strconv.Atoi(fields[1])
  if err != nil { log.Fatal(err) }
  gen.size, err = strconv.ParseFloat(fields[6], 64)
  if err != nil { gen.size = -1.0 }
  if gen.size > 0 { gen.size /= 1000.0 }
  gen.replicons = fields[9]
#+end_src
#+begin_src latex
  We close the virus genomes file.
#+end_src
#+begin_src go <<Close files, Pa.~\ref{pa:tdb}>>=
  vf.Close()
#+end_src
#+begin_src latex
  To insert the genomes into the \ty{genomes} table, we use a
  transaction like we did for the \ty{taxon} table.
#+end_src
#+begin_src go <<Insert genomes, Pa.~\ref{pa:tdb}>>=
  tx, err = db.Begin()
  if err != nil { log.Fatal(err) }
  sqlStmt = "insert into genome(taxid, replicons, size) " +
	  "values(?, ?, ?)"
  stmt, err = tx.Prepare(sqlStmt)
  if err != nil { log.Fatal(err) }
  //<<Insert rows into table \ty{genome}, Pa.~\ref{pa:tdb}>>
  tx.Commit()
  stmt.Close()
#+end_src
#+begin_src latex
  We insert each entry in the \ty{genomes} slice into table \ty{genome}.
#+end_src
#+begin_src go <<Insert rows into table \ty{genome}, Pa.~\ref{pa:tdb}>>=
  for _, g := range genomes {
	  _, err = stmt.Exec(g.taxid, g.replicons, g.size)
	  if err != nil { log.Fatal(err) }
  }
#+end_src
#+begin_src latex
  The database is constructed, so we close it.
#+end_src
#+begin_src go <<Close database, Pa.~\ref{pa:tdb}>>=
  db.Close()
#+end_src
#+begin_src latex
  \subsection{\ty{OpenTaxonomyDB}}
  The function \ty{OpenTaxonomyDB} opens an existing taxonomy database
  and returns a pointer to it.
#+end_src
#+begin_src go <<Functions, Pa.~\ref{pa:tdb}>>=
  // OpenTaxonomyDB opens an existing taxonomy database and returns a
  // pointer to it.
  func OpenTaxonomyDB(name string) *TaxonomyDB {
	  db := new(TaxonomyDB)
	  var err error
	  db.db, err = sql.Open("sqlite3", name)
	  if err != nil { log.Fatal(err) }
	  return db
  }
#+end_src
#+begin_src latex
  \subsection{\ty{Close}}
  The method \ty{Close} closes a taxonomy database.
#+end_src
#+begin_src go <<Methods, Pa.~\ref{pa:tdb}>>=
  // Close closes the taxonomy database.
  func (t *TaxonomyDB) Close() {
	  t.db.Close()
  }
#+end_src
#+begin_src latex
  \subsection{\ty{NewTaxonomy}}
  The method \ty{NewTaxonomy} reads the taxonomy from the database. For
  this, we first parse the taxon table and store its contents in two
  maps, \ty{tax} and \ty{parents}. \ty{tax} maps a taxon-ID, which is an
  integer, to a taxon node. \ty{parents} maps a taxon's ID to that of
  its parent. From these two maps we then construct the tree.
#+end_src
#+begin_src go <<Methods, Pa.~\ref{pa:tdb}>>=
  // NewTaxonomy reads the taxonomy from the database.
  func (t *TaxonomyDB) NewTaxonomy() tax.Taxonomy {
	  ta := make(map[int]*tax.Node)
	  parents := make(map[int]int)
	  //<<Parse taxon table, Pa.~\ref{pa:tdb}>>
	  //<<Construct tree, Pa.~\ref{pa:tdb}>>
	  return ta
  }
#+end_src
#+begin_src latex
  We import \ty{tax}.
#+end_src
#+begin_src go <<Imports, Pa.~\ref{pa:tdb}>>=
  "github.com/evolbioinf/neighbors/tax"
#+end_src
#+begin_src latex
  We query the \ty{taxon} table, store the taxa, and check for errors at the
  end.
#+end_src
#+begin_src go <<Parse taxon table, Pa.~\ref{pa:tdb}>>=
  //<<Query taxon table, Pa.~\ref{pa:tdb}>>
  //<<Store taxa, Pa.~\ref{pa:tdb}>>
  //<<Check for errors in taxon query, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  Our query of the \ty{taxon} table returns the full table.
#+end_src
#+begin_src go <<Query taxon table, Pa.~\ref{pa:tdb}>>=
  q := "select name, taxid, parent from taxon"
  rows, err := t.db.Query(q)
  if err != nil {
	  log.Fatalf("couldn't run %q", q)
  }
  defer rows.Close()
#+end_src
#+begin_src latex
  We iterate over the rows of the query and store each row as a
  taxon. We also store its parent.
#+end_src
#+begin_src go <<Store taxa, Pa.~\ref{pa:tdb}>>=
  var taxid, parent int
  var name string
  for rows.Next() {
	  err = rows.Scan(&name, &taxid, &parent)
	  if err != nil {
		  log.Fatal(err)
	  }
	  v := &(tax.Node{ID: taxid, Name: name})
	  ta[taxid] = v
	  parents[taxid] = parent
  }
#+end_src
#+begin_src latex
  The query table might be left in an error state, in which case we
  bail.
#+end_src
#+begin_src go <<Check for errors in taxon query, Pa.~\ref{pa:tdb}>>=
  err = rows.Err()
  if err != nil {
	  log.Fatal(err)
  }
#+end_src
#+begin_src latex
  The tree topology is now implicit in the map of parents. To construct
  an explicit tree from this, we iterate over all taxa and access the
  corresponding child/parent pairs. As the parent of the root is the
  root itself, we might be dealing with two roots at this
  point. Treating them like an ordinary child/parent pair would lead to
  the construction of a loop, so we check for this before setting the
  links between parent and child.
#+end_src
#+begin_src go <<Construct tree, Pa.~\ref{pa:tdb}>>=
  for k, v := range parents {
	  if k != v {
		  child := ta[k]
		  parent := ta[v]
		  //<<Set links between parent and child, Pa.~\ref{pa:tdb}>>
	  }
  }
#+end_src
#+begin_src latex
  We set the child's parent link and add it to its parent's list of
  children.
#+end_src
#+begin_src go <<Set links between parent and child, Pa.~\ref{pa:tdb}>>=
  child.Parent = parent
  if parent.Child == nil {
	  parent.Child = child
	  parent.Child.LastSib = child
  } else {
	  c := parent.Child
	  c.LastSib.Sib = child
	  c.LastSib = child
  }
#+end_src
#+begin_src latex
  !The method \ty{Replicons} takes as parameter a taxon-ID and returns a
  !slice of genome accessions.

  We query for replicons and then store them in the string slice we
  return.
#+end_src
#+begin_src go <<Methods, Pa.~\ref{pa:tdb}>>=
  func (t *TaxonomyDB) Replicons(tid int) []string {
	  var reps []string
	  //<<Query for replicions, Pa.~\ref{pa:tdb}>>
	  //<<Store replicons, Pa.~\ref{pa:tdb}>>
	  return reps
  }
#+end_src
#+begin_src latex
  We generate the query and execute it, which returns a set of table
  rows. The rows are later closed again.
#+end_src
#+begin_src go <<Query for replicions, Pa.~\ref{pa:tdb}>>=
  tmpl := "select replicons from genome where taxid=%d " +
	  "and replicons <> '-'"
  q := fmt.Sprintf(tmpl, tid)
  rows, err := t.db.Query(q)
  if err != nil {
	  log.Fatal(err)
  }
  defer rows.Close()
#+end_src
#+begin_src latex
  We import \ty{fmt}.
#+end_src
#+begin_src go <<Imports, Pa.~\ref{pa:tdb}>>=
  "fmt"
#+end_src
#+begin_src latex
  We append each replicon to our slice of replicons.
#+end_src
#+begin_src go <<Store replicons, Pa.~\ref{pa:tdb}>>=
  s := ""
  for rows.Next() {
	  err := rows.Scan(&s)
	  if err != nil {
		  log.Fatal(err)
	  }
	  reps = append(reps, s)
  }
#+end_src
#+begin_src latex
  \subsection{Testing}
  The outline of our code for testing \ty{tdb} has a hook for the
  testing logic.
#+end_src
#+begin_src go <<tdb_test.go>>=
  package tdb

  import (
	  "testing"
  )

  func TestTdb(t *testing.T) {
	  //<<Testing, Pa.~\ref{pa:tdb}>>
  }
#+end_src
#+begin_src latex
  We test the function \ty{NewTaxonomyDB}, and the methods
  \ty{NewTaxonomy} and \ty{Replicons}.
#+end_src
#+begin_src go <<Testing, Pa.~\ref{pa:tdb}>>=
  //<<Test \ty{NewTaxonomyDB}, Pa.~\ref{pa:tdb}>>
  //<<Test \ty{NewTaxonomy}, Pa.~\ref{pa:tdb}>>
  //<<Test \ty{Replicons}, Pa.~\ref{pa:tdb}>>
#+end_src
#+begin_src latex
  We build a small database, \ty{taxSmall.db}.
#+end_src
#+begin_src go <<Test \ty{NewTaxonomyDB}, Pa.~\ref{pa:tdb}>>=
  p := "../data/"
  no := p + "nodesTest.dmp"
  na := p + "namesTest.dmp"
  pr := p + "prokaryotes.txt"
  eu := p + "eukaryotes.txt"
  vi := p + "viruses.txt"
  d1 := p + "taxSmall.db"
  NewTaxonomyDB(no, na, pr, eu, vi, d1)
#+end_src
#+begin_src latex
  We've built the small database, now we extract the taxonomy from it
  and check it has 9 entries.
#+end_src
#+begin_src go <<Test \ty{NewTaxonomyDB}, Pa.~\ref{pa:tdb}>>=
  taxdb := OpenTaxonomyDB(d1)
  ta := taxdb.NewTaxonomy()
  if len(ta) != 9 {
	  t.Errorf("get %d rows, want 9", len(ta))
  }
#+end_src
#+begin_src latex
  We open a complete taxonomy database, get a new taxonomy from it, and
  the name of one entry.
#+end_src
#+begin_src go <<Test \ty{NewTaxonomy}, Pa.~\ref{pa:tdb}>>=
  d2 := p + "tax.db"
  taxdb = OpenTaxonomyDB(d2)
  ta = taxdb.NewTaxonomy()
  want := "Bernardetia litoralis"
  get := ta[999].Name
  if get != want {
	  t.Errorf("get: %q; want: %q", get, want)
  }
#+end_src
#+begin_src latex 
  We submit three taxon-IDs to the method \ty{Replicons} and print out the
  result.
#+end_src
#+begin_src go <<Test \ty{Replicons}, Pa.~\ref{pa:tdb}>>=
  tid := 866775
  reps := taxdb.Replicons(tid)
  get = reps[0]
  want = "chromosome:NC_015278.1/CP002512.1"
  if get != want {
	  t.Errorf("get: %q; want: %q", get, want)
  }
#+end_src

