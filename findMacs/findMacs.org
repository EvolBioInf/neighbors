#+begin_export latex
\section{\ty{findMacs}}
The program \ty{findMacs} finds marker candidates for sets of target
genomes. It takes as input a set of $k$ target genomes,
$T=\{t_1,t_2,...,t_k\}$, and a set of $l$ neighbor genomes,
$N=\{n_1,n_2,...,n_l\}$, and returns the markers, $M$, which are the
regions common to the targets that are absent from the neighbors. The
program works in three steps, initialization, subtraction of
neighbors, and intersection of targets. In the initialization step,
the markers are set to an arbitrary target, we use $t_1$, which serves
as coordinate system throughout the computation.
\begin{equation}\label{eq:ini}
M\leftarrow t_1
\end{equation}
In the subtraction of neighbors, any marker region homologous to a
neighbor region is removed.
\begin{equation}\label{eq:sub}
M\leftarrow M\setminus N,
\end{equation}
To make sure the markers are ubiquitous among the targets, they are
intersected in the third stepwith all targets but $t_1$.
\begin{equation}\label{eq:int}
M\leftarrow M\cap t_2\cap t_3\cap...\cap t_k.
\end{equation}

The three steps are further detailed in Algorithm~\ref{alg:fin}:

\begin{enumerate}
  \item Initialization (line 1): We initialize the marker set, $M$, to $t_1$.
    
  \item Subtraction of neighbors (lines 2--4): We intersect each
    neighbor with $t_1$ and subtract the result from $M$. An example
    of this is shown in Figure~\ref{fig:fin}A.
  \item Intersection (lines 5--7): We remove all regions from $M$ that
    are not in the intersection of $t_1$ and $t_i$, where $i$ ranges
    from 2 to $k$. An example of this is shown in
    Figure~\ref{fig:fin}B.
\end{enumerate}

\begin{algorithm}
  \caption{Finding markers by comparing targets to neighbors.}\label{alg:fin}
  \begin{algorithmic}[1]
    \input{../findMacs/alg}
  \end{algorithmic}
\end{algorithm}


\begin{figure}
  \begin{center}
    \begin{tabular}{c}
      \textbf{A}\\
      \input{../findMacs/sub}\\
      \textbf{B}\\
      \input{../findMacs/int}
    \end{tabular}
  \end{center}
  \caption{Illustration of the subtraction (\textbf{A}) and
    intersection (\textbf{B}) steps in \ty{findMacs} with three
    targets, $t_1,t_2$,and $t_3$; the dotted vertical lines in panel
    \textbf{B} indicate the expected result.}\label{fig:fin}
\end{figure}

Algorithm~\ref{alg:fin} is centered on two operations on sequence
regions, intersection and subtraction. Intersections are calculated by
aligning sequences with \ty{minimap2}, which returns sets of matching
intervals. Such sets of intervals can then be subtracted from each
other by calls to the \ty{subtract} function of \ty{bedtools}. So, for
every $\cap$ in Algorithm~\ref{alg:fin} think \ty{minimap2}, for every
$\setminus$ think \ty{bedtools}.

Let's explore in more detail how \ty{bedtools} can be used to
implement the subtraction part of Algorithm~\ref{alg:fin}. For this we
store the intersections $I_1$, $I_2$, and $I_3$ from
Figures~\ref{fig:fin}A and B as BED intervals in files
\ty{findMacs/i[123].bed}. Bed intervals are half-open to the left,
hence \ty{i1.bed} contains $I_1=\{(0,1],(3,6],(8,10]\}$ written in
      three columns:
\begin{verbatim}
t1	0	1
t1	3	6
t1	8	10
\end{verbatim}
In addition, there is also the interval $t_1=(0,10]$ in
  \ty{findMacs/t1.bed}. We write a little script to demonstrate the
  subtraction in equation~(\ref{eq:sub}) and the intersection in
  equation~(\ref{eq:int}) with \ty{bedtools}.
  \bpr{bedtools.sh}{pr:bed}
#+end_export
#+begin_src sh <<bedtools.sh>>=
  //<<Subtraction, Pr. \ref{pr:bed}>>
  //<<Intersection, Pr. \ref{pr:bed}>>
#+end_src
#+begin_export latex
\epr We subtract $I_1$ from $t_1$ to get $M$.
#+end_export
#+begin_src sh <<Subtraction, Pr. \ref{pr:bed}>>=
  bedtools subtract -a t1.bed -b i1.bed > m.bed
#+end_src
#+begin_export latex
For the intersection we iterate over $I_2$ and $I_3$, subtract each
one from $t_1$, and subtract the difference from $M$. This gives us
the final two intervals, $M_2=\{(2,3], (7,8]\}$, which are the
    intervals indicated by the dotted vertical lines in
    Figure~\ref{fig:fin}B. At the end we remove the intermediate file
    \ty{d.bed} again.
#+end_export
#+begin_src sh <<Intersection, Pr. \ref{pr:bed}>>=
  for i in $(seq 2 3)
  do
      bedtools subtract -a t1.bed -b i${i}.bed > d.bed
      bedtools subtract -a m.bed -b d.bed > t.bed
      mv t.bed m.bed
  done
  cat m.bed
  rm d.bed
#+end_src
#+begin_export latex
\begin{verbatim}
t1       2       3
t1       7       8
\end{verbatim}
\section*{Implementation}
The outline of \ty{findMacs} has hooks for imports, functions, types,
methods, and the logic of the main function. \bpr{findMacs}{pr:fin}
#+end_export
#+begin_src go <<findMacs.go>>=
  package main

  import (
	  //<<Imports, Pr. \ref{pr:fin}>>
  )
  //<<Types, Pr. \ref{pr:fin}>>
  //<<Methods, Pr. \ref{pr:fin}>>
  //<<Functions, Pr. \ref{pr:fin}>>
  func main() {
	  //<<Main function, Pr. \ref{pr:fin}>>
  }
#+end_src
#+begin_export latex
\epr
In the main function interact with the user, find the marker
candidates, and print them.
#+end_export
#+begin_src go <<Main function, Pr. \ref{pr:fin}>>=
  //<<Interact with user, Pr. \ref{pr:fin}>>
  //<<Find marker candidates, Pr. \ref{pr:fin}>>
  //<<Print marker candidates, Pr. \ref{pr:fin}>>
#+end_src
#+begin_export latex
To interact with the user, we prepare the \ty{log} package, set the
usage, declare the options, and parse them.
#+end_export
#+begin_src go <<Interact with user, Pr. \ref{pr:fin}>>=
  clio.PrepLog("findMacs")
  //<<Set usage, Pr. \ref{pr:fin}>>
  //<<Declare options, Pr. \ref{pr:fin}>>
  //<<Parse options, Pr. \ref{pr:fin}>>
#+end_src
#+begin_export latex
We import \ty{clio}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:fin}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_export latex
The usage consists of the usage message itself, an explanation of
the purpose of \ty{findMacs}, and an example command.
#+end_export
#+begin_src go <<Set usage, Pr. \ref{pr:fin}>>=
  u := "findMacs [option]... -t <targets> -n <neighbors>"
  p := "Find marker candidates from target " +
	  "and neighbor sequences."
  e := "findMacs -t targets/ -n neighbors/"
  clio.Usage(u, p, e)
#+end_src
#+begin_export latex
We declare the version option (\ty{-v}), the target directory
(\ty{-t}), the neighbor directory (\ty{-n}), a minimum marker length
(\ty{-m}), and a parameter string for \ty{minimap2} (\ty{-p}). Our
default parameter string for \ty{minipap2} is \ty{-c}, which means we
get the CIGAR string for reconstructing the alignment.
#+end_export
#+begin_src go <<Declare options, Pr. \ref{pr:fin}>>=
  optV := flag.Bool("v", false, "version")
  optT := flag.String("t", "", "target directory")
  optN := flag.String("n", "", "neighbor directory")
  optM := flag.Int("m", 100, "minimum marker length")
  optP := flag.String("p", "-c", "parameters for minimap2")
#+end_src
#+begin_export latex
We import \ty{flag}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:fin}>>=
  "flag"
#+end_src
#+begin_export latex
We parse the options and respond to the version request, as this stops
the program. Then we check that the user has set the target and
neighbor directories. If not, we bail with a friendly message.
#+end_export
#+begin_src go <<Parse options, Pr. \ref{pr:fin}>>=
  flag.Parse()
  if *optV {
	  util.PrintInfo("findMacs")
  }
  tmpl := "Please submit a directory of %s sequences.\n"
  if *optT == "" {
	  log.Fatalf(tmpl, "target")
  }
  if *optN == "" {
	  log.Fatalf(tmpl, "neighbor")
  }	
#+end_src
#+begin_export latex
We import \ty{util} and \ty{log}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:fin}>>=
  "github.com/evolbioinf/neighbors/util"
  "log"
#+end_src
#+begin_export latex
To find marker candidates, we read the names of the target and
neighbor sequence files and check them for overlap---there shouldn't
be any. Then we pick the target representative, $t_1$, subtract the
neighbors from $t_1$ to calculate $M$, and intersect $M$ with the
targets.
#+end_export
#+begin_src go <<Find marker candidates, Pr. \ref{pr:fin}>>=
  //<<Read names of targets and neighbors, Pr. \ref{pr:fin}>>
  //<<Check names, Pr. \ref{pr:fin}>>
  //<<Assign $t_1$, Pr. \ref{pr:fin}>>
  //<<Subtract neighbors from $t_1$ to calculate $M$, Pr. \ref{pr:fin}>>
  //<<Intersect $M$ with targets, Pr. \ref{pr:fin}>>
#+end_src
#+begin_export latex
We read the names of the targets and neighbors with the function
\ty{readDir}. If either of the directories is empty, we abort with
message.
#+end_export
#+begin_src go <<Read names of targets and neighbors, Pr. \ref{pr:fin}>>=
  targets := readDir(*optT)
  if len(targets) == 0 {
	  log.Fatalf("%s is empty\n", *optT)
  }
  neighbors := readDir(*optN)
  if len(neighbors) == 0 {
	  log.Fatalf("%s is empty\n", *optN)
  }
#+end_src
#+begin_export latex
The function \ty{readDir} takes as argument a directory name and
returns a slice of strings with the paths of the sequence files in the
directory. To make sure we only return sequence files, we check each
directory entry before storing it.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:fin}>>=
  func readDir(dir string) []string {
	  dirEntries, err := os.ReadDir(dir)
	  util.Check(err)
	  paths := make([]string, 0)
	  for _, dirEntry := range dirEntries {
		  path := dir + "/" + dirEntry.Name()
		  //<<Check directory entry, Pr. \ref{pr:fin}>>
		  paths = append(paths, path)
	  }
	  return paths
  }
#+end_src
#+begin_export latex
We import \ty{os}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:fin}>>=
  "os"
#+end_src
#+begin_export latex
We test whether the directory entry is a file rather than a
subdirectory. If it is indeed a file, we test whether it is a
nucleotide file.
#+end_export
#+begin_src go <<Check directory entry, Pr. \ref{pr:fin}>>=
  //<<Is directory entry a file? Pr. \ref{pr:fin}>>
  //<<Is directory entry a nucleotide file? Pr. \ref{pr:fin}>>
#+end_src
#+begin_export latex
If the directory entry is a subdirectory rather than a file we skip it
and warn the user.
#+end_export
#+begin_src go <<Is directory entry a file? Pr. \ref{pr:fin}>>=
  if dirEntry.IsDir() {
	  fmt.Fprintf(os.Stderr,
		  "skipping subdirectory %s\n", path)
	  continue
  }
#+end_src
#+begin_export latex
We import \ty{fmt} and \ty{os}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:fin}>>=
  "fmt"
  "os"
#+end_src
#+begin_export latex
According to Wikipedia, nucleotide FASTA files have one of five
extensions, \ty{.fasta}, \ty{.fna}, \ty{.ffn}, \ty{.frn}, and
\ty{.fa}. If a file has a different extension, we skip it with warning.
#+end_export
#+begin_src go <<Is directory entry a nucleotide file? Pr. \ref{pr:fin}>>=
  ext := filepath.Ext(dirEntry.Name())
  if ext != ".fasta" && ext != ".fna" && ext != "ffn" &&
	  ext != ".frn" && ext != ".fa" {
	  m := "%s doesn't seem to be a nucleotide FASTA file; " +
		  "skipping it"
	  fmt.Fprintf(os.Stderr, m, path)
	  continue
  }
#+end_src
#+begin_export latex
We import \ty{filepath}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:fin}>>=
  "path/filepath"
#+end_src
#+begin_export latex
To make sure the names don't overlap, we enter them in a map, first
the targets, then the neighbors.
#+end_export
#+begin_src go <<Check names, Pr. \ref{pr:fin}>>=
  mm := make(map[string]bool)
  //<<Enter targets, Pr. \ref{pr:fin}>>
  //<<Enter neighbors, Pr. \ref{pr:fin}>>
#+end_src
#+begin_export latex
We mark each target in the map as ``true''.
#+end_export
#+begin_src go <<Enter targets, Pr. \ref{pr:fin}>>=
  for _, target := range targets {
	  mm[target] = true
  }
#+end_src
#+begin_export latex
If a neighbor has the same name as a target, we bail with message.
#+end_export
#+begin_src go <<Enter neighbors, Pr. \ref{pr:fin}>>=
  for _, neighbor := range neighbors {
	  if mm[neighbor] {
		  m := "found %s/%s and %s/%s; please " +
			  "make sure targets and " +
			  "neighbors don't overlap"
		  log.Fatalf(m, *optT, neighbor, *optN,
			  neighbor)
	  }
  }
#+end_src
#+begin_export latex
We assign $t_1$.
#+end_export
#+begin_src go <<Assign $t_1$, Pr. \ref{pr:fin}>>=
  t1 := targets[0]
#+end_src
#+begin_export latex
We begin our construction of the markers, $M$, by initializing them to
the intervals that correspond to the sequences in $t_1$. Then we
iterate over the neighbors and intersect each one with $t_1$ using the
function \ty{intersect}, which runs \ty{minimap2}, hence we pass the
\ty{minimap2} parameters. The resulting intersection is subtracted
from $M$ using another as yet unwritten function, \ty{subtract}. At
the end of the loop we've implemented equation~(\ref{eq:sub}).
#+end_export
#+begin_src go <<Subtract neighbors from $t_1$ to calculate $M$, Pr. \ref{pr:fin}>>=
  //<<Initialize $M$, Pr. \ref{pr:fin}>>
  for _, neighbor := range neighbors {
	  in := intersect(neighbor, t1, *optP)
	  markers = subtract(markers, in)
  }
#+end_src
#+begin_export latex
An interval consists of a chromosome, a start, and an end.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:fin}>>=
  type Interval struct {
	  Chr string
	  Start int
	  End int
  }
#+end_src
#+begin_export latex
We initialize $M$ with the intervals corresponding to the sequences
making up $t_1$, which corresponds to line 1 in
Algorithm~\ref{alg:fin}. In the intersection part of
Algorithm~\ref{alg:fin}, lines 5--7, we need a similar initialization,
so we delegate the conversion between sequences and intervals to the
function \ty{seq2iv}.
#+end_export
#+begin_src go <<Initialize $M$, Pr. \ref{pr:fin}>>=
  markers := seq2iv(t1)
#+end_src
#+begin_export latex
The function \ty{seq2iv} takes as parameter the name of a sequence
file and returns the sequences it contains as a slice of intervals. We
declare the slice of intervals, open the sequence file, and scan
it. Each sequence corresponds to an interval which we store. Then we
close the sequence file and return the intervals.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:fin}>>=
  func seq2iv(fn string) []Interval {
	  intervals := make([]Interval, 0)
	  f, err := os.Open(fn)
	  util.Check(err)
	  sc := fasta.NewScanner(f)
	  for sc.ScanSequence() {
		  //<<Store interval, Pr. \ref{pr:fin}>>
	  }
	  f.Close()
	  return intervals
  }
#+end_src
#+begin_export latex
For a given sequence, we determine its length, $\ell$, and store the
interval $(0,\ell]$ to $M$. The ``chromosome'' of that interval is the
  first token of the sequence's FASTA header.
#+end_export
#+begin_src go <<Store interval, Pr. \ref{pr:fin}>>=
  s := sc.Sequence()
  l := len(s.Data())
  h := strings.Fields(s.Header())
  interval := Interval{Chr: h[0], Start: 0, End: l}
  intervals = append(intervals, interval)
#+end_src
#+begin_export latex
We import \ty{fasta} and \ty{strings}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:fin}>>=
  "github.com/evolbioinf/fasta"
  "strings"
#+end_src
#+begin_export latex
The function \ty{intersect} takes as arguments a the names of the
reference and query files. It then compares the reference and the
query using \ty{minimap2} and returns the hits, i.e. the intersection,
as a slice of intervals.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:fin}>>=
  func intersect(r, q, p string) []Interval {
	  var hits []Interval
	  //<<Construct \ty{minimap2} command, Pr. \ref{pr:fin}>>
	  //<<Run \ty{minimap2}, Pr. \ref{pr:fin}>>
	  //<<Extract \ty{minimap2} hits, Pr. \ref{pr:fin}>>
	  return hits
  }
#+end_src
#+begin_export latex
We construct the \ty{minimap2} command from a template with variables
for parameters, reference, and query. We convert that template to an
argument string, which we split into the individual arguments before
we set them as the command arguments.
#+end_export
#+begin_src go <<Construct \ty{minimap2} command, Pr. \ref{pr:fin}>>=
  tm := "minimap2 %s %s %s"
  as := fmt.Sprintf(tm, p, r, q)
  args := strings.Fields(as)
  cmd := exec.Command("minimap2")
  cmd.Args = args
#+end_src
#+begin_export latex
We import \ty{exec}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:fin}>>=
  "os/exec"
#+end_src
#+begin_export latex
We run \ty{minimap2}, store its output to stdout, and check
its error.
#+end_export
#+begin_src go <<Run \ty{minimap2}, Pr. \ref{pr:fin}>>=
  out, err := cmd.Output()
  util.Check(err)
#+end_src
#+begin_export latex
We split the output from \ty{minimap2} into lines. Since the
\ty{minimap2} output ends in a newline, the last string returned from
the splitting is empty, and we remove it. Each non-empty line is split
into its fields, one of which is the CIGAR field. We parse the CIGAR
field to get the alignment.
#+end_export
#+begin_src go <<Extract \ty{minimap2} hits, Pr. \ref{pr:fin}>>=
  nwl := []byte("\n")
  tab := []byte("\t")
  lines := bytes.Split(out, nwl)
  lines = lines[0:len(lines)-1]
  for _, line := range lines {
	  //<<Split line, Pr. \ref{pr:fin}>>
	  //<<Parse CIGAR, Pr. \ref{pr:fin}>>
  }
#+end_src
#+begin_export latex
We import \ty{bytes}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:fin}>>=
  "bytes"
#+end_src
#+begin_export latex
Each line consists of fields, three of which are relevant for us, the
query name and start position in columns 1 and 3 and the CIGAR string
in column the last column (Table~\ref{tab:col}).
\begin{table}
  \caption{The columns of \ty{minimap2} output used by \ty{findMacs}.}\label{tab:col}
  \begin{center}
    \begin{tabular}{rl}
      \hline
      Column & Meaning\\\hline
      1 & query name\\
      3 & query start, zero-based\\
      last & CIGAR string\\\hline
    \end{tabular}
  \end{center}
\end{table}
#+end_export
#+begin_src go <<Split line, Pr. \ref{pr:fin}>>=
  fields := bytes.Split(line, tab)
  chr := string(fields[0])
  start, err := strconv.Atoi(string(fields[2]))
  util.Check(err)
  l := len(fields)
  cigar := fields[l-1]
#+end_src
#+begin_export latex
We import \ty{strconv}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:fin}>>=
  "strconv"
#+end_src
#+begin_export latex
A CIGAR string has the format
\[
\ty{cg:Z:}c_1o_1c_2o_2...,
\]
where \ty{cg:Z:} is an identifying prefix, $c_i$ is the $i-th$ count
of the $i$-th operator, $o_i$. Operators are single characters. We
construct a slice for them and a slice for the counts, and extract the
operators and the counts from the CIGAR string. Then we convert the
counts and operators into hits.
#+end_export
#+begin_src go <<Parse CIGAR, Pr. \ref{pr:fin}>>=
  if bytes.HasPrefix(cigar, []byte("cg:Z:")) {
	  cigar = cigar[5:]
  } else {
	  log.Fatalf("%s is not a CIGAR string", cigar)
  }
  operators := make([]byte, 0)
  counts := make([]int, 0)
  //<<Extract operators, Pr. \ref{pr:fin}>>
  //<<Extract counts, Pr. \ref{pr:fin}>>
  //<<Convert operators and counts to hits, Pr. \ref{pr:fin}>>
#+end_src
#+begin_export latex
All characters that are not digits are operators. We store them and
replace them with a blank.
#+end_export
#+begin_src go <<Extract operators, Pr. \ref{pr:fin}>>=
  for i, c := range cigar {
	  if !unicode.IsDigit(rune(c)) {
		  operators = append(operators, c)
		  cigar[i] = ' '
	  }
  }
#+end_src
#+begin_export latex
We import \ty{unicode}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:fin}>>=
  "unicode"
#+end_src
#+begin_export latex
The blanks in the CIGAR string allow us to conveniently split it into
count strings, which we then convert to count integers.
#+end_export
#+begin_src go <<Extract counts, Pr. \ref{pr:fin}>>=
  countStrings := strings.Fields(string(cigar))
  for _, countString := range countStrings {
	  count, err := strconv.Atoi(countString)
	  util.Check(err)
	  counts = append(counts, count)
  }
#+end_src
#+begin_export latex
There are three operators, \ty{M} for match, \ty{I} for insertion, and
\ty{D} for deletion. Deletions and insertions are reported with
respect to the query, which in our case is always $t_1$.  We deal with
the match case separately. If we have an insertion, we advance the
current start to the next start. Since start positions are zero-based,
we increment the current start position by the count. The third case,
deletion, has no consequences. So we can directly advance to the case
where we found a rogue operator.

#+end_export
#+begin_src go <<Convert operators and counts to hits, Pr. \ref{pr:fin}>>=
  for i, count := range counts {
	  operator := operators[i]
	  if operator == 'M' {
		  //<<Deal with match , Pr. \ref{pr:fin}>>
	  } else if operator == 'I' {
		  start += count
	  } else if operator != 'D' {
		  //<<Deal with rogue operator, Pr. \ref{pr:fin}>>
	  }
  }
#+end_src
#+begin_export latex
A match is a hit, which we store as the corresponding interval. An
interval in BED notation has a zero-based start and a one-based
end. We store it and also advance the current start position to the
previous end position.
#+end_export
#+begin_src go <<Deal with match , Pr. \ref{pr:fin}>>=
  end := start + count
  hit := Interval{Chr: chr, Start: start, End: end}
  hits = append(hits, hit)
  start = end
#+end_src
#+begin_export latex
If we have stumbled upon a rogue operator, we bail.
#+end_export
#+begin_src go <<Deal with rogue operator, Pr. \ref{pr:fin}>>=
  log.Fatalf("unknown CIGAR operator %c\n", operator)
#+end_src
#+begin_export latex
We have now written the function \ty{intersect}. The second as yet
unwritten function is \ty{subtract}. It takes as parameters two slices
of integers, $a$ and $b$, and calculates the difference $a-b$ using
\ty{bedtools}. For storing the difference, we declare the interval
slice \ty{diff}. Subtraction with \ty{bedtools} works best with
intervals sorted by chromosome and start position, so we sort $a$ and
$b$ before we write them to file. Then we construct the \ty{bedtools}
subtraction command, run it, analyze its output, and delete the files
we created.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:fin}>>=
  func subtract(a, b []Interval) []Interval {
	  var diff []Interval
	  //<<Sort $a$ and $b$, Pr. \ref{pr:fin}>>
	  //<<Write $a$ and $b$ to file, Pr. \ref{pr:fin}>>
	  //<<Construct subtraction command, Pr. \ref{pr:fin}>>
	  //<<Run subtraction, Pr. \ref{pr:fin}>>
	  //<<Analyze output of subtraction, Pr. \ref{pr:fin}>>
	  //<<Delete files for $a$ and $b$, Pr. \ref{pr:fin}>>
	  return diff
  }
#+end_src
#+begin_export latex
We sort $a$ and $b$ by casting them to a sortable type,
\ty{IntervalSlice}, and applying the \ty{Sort} function to that.
#+end_export
#+begin_src go <<Sort $a$ and $b$, Pr. \ref{pr:fin}>>=
  sort.Sort(IntervalSlice(a))
  sort.Sort(IntervalSlice(b))
#+end_src
#+begin_export latex
We import \ty{sort}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:fin}>>=
  "sort"
#+end_src
#+begin_export latex
We declare the type \ty{IntervalSlice} as a slice of intervals.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:fin}>>=
  type IntervalSlice []Interval
#+end_src
#+begin_export latex
An \ty{IntervalSlice} provides the three methods promised in the
\ty{Sort} interface, \ty{Len}, \ty{Less}, and \ty{Swap}. We sort with
two keys, the primary sort key is the chromosome, the secondary the
start position.
#+end_export
#+begin_src go <<Methods, Pr. \ref{pr:fin}>>=
  func (p IntervalSlice) Len() int { return len(p) }
  func (p IntervalSlice) Less(i, j int) bool {
	  if p[i].Chr == p[j].Chr {
		  return p[i].Chr < p[j].Chr
	  } else {
		  return p[i].Start < p[j].Start
	  }
  }
  func (p IntervalSlice) Swap(i, j int) {
	  p[i], p[j] = p[j], p[i]
  }
#+end_src
#+begin_export latex
We create temporary files for $a$ and $b$ and write the intervals to
them.
#+end_export
#+begin_src go <<Write $a$ and $b$ to file, Pr. \ref{pr:fin}>>=
  af, err := os.CreateTemp(os.TempDir(), "a*.bed")
  util.Check(err)
  bf, err := os.CreateTemp(os.TempDir(), "b*.bed")
  util.Check(err)
  for _, iv := range a {
	  fmt.Fprintf(af, "%s\t%d\t%d\n", iv.Chr, iv.Start,
		  iv.End)
  }
  for _, iv := range b {
	  fmt.Fprintf(bf, "%s\t%d\t%d\n", iv.Chr, iv.Start,
		  iv.End)
  }
#+end_src
#+begin_export latex
For the subtraction command we retrieve the names of the two temporary
files.
#+end_export
#+begin_src go <<Construct subtraction command, Pr. \ref{pr:fin}>>=
  an := af.Name()
  bn := bf.Name()
  cmd := exec.Command("bedtools", "subtract", "-a", an, "-b", bn)
#+end_src
#+begin_export latex
We run the subtraction and store the results written to stdout.
#+end_export
#+begin_src go <<Run subtraction, Pr. \ref{pr:fin}>>=
  out, err := cmd.Output()
  util.Check(err)
#+end_src
#+begin_export latex
We split the output of the subtraction into lines. Each line consists
of three rows, chr, start, and end. We package this into an interval,
which we store in \ty{diff}.
#+end_export
#+begin_src go <<Analyze output of subtraction, Pr. \ref{pr:fin}>>=
  lines := bytes.Split(out, []byte("\n"))
  lines = lines[0:len(lines)-1]
  for _, line := range lines {
	  fields := strings.Split(string(line), "\t")
	  c := fields[0]
	  s, err := strconv.Atoi(fields[1])
	  util.Check(err)
	  e, err := strconv.Atoi(fields[2])
	  util.Check(err)
	  iv := Interval{Chr: c, Start: s, End: e}
	  diff = append(diff, iv)
  }
#+end_src
#+begin_export latex
The subtraction is done, so we delete the files for $a$ and $b$.
#+end_export
#+begin_src go <<Delete files for $a$ and $b$, Pr. \ref{pr:fin}>>=
  err = os.Remove(an)
  util.Check(err)
  err = os.Remove(bn)
  util.Check(err)
#+end_src
#+begin_export latex
We have now implemented the subtraction summarized in
equation~(\ref{eq:sub}), next we implement the intersection summarized
in equation~(\ref{eq:int}) and lines 5--7 of
Algorithm~\ref{alg:fin}. We do this by again converting the sequences
in $t_1$ to intervals. Then we iterate over the targets except for
$t_1$, intersect them with $t_1$, subtract the result from $t_1$, and
subtract the difference from $M$.
#+end_export
#+begin_src go <<Intersect $M$ with targets, Pr. \ref{pr:fin}>>=
  t1i := seq2iv(t1)
  for i := 1; i < len(targets); i++ {
	  target := targets[i]
	  in := intersect(target, t1, *optP)
	  x := subtract(t1i, in)
	  markers = subtract(markers, x)
  }
#+end_src
#+begin_export latex
$M$ now contains the desired set of marker candidates. We print the
markers of minimum length as a tab-delimited table in the BED notation
we have used throughout.
#+end_export
#+begin_src go <<Print marker candidates, Pr. \ref{pr:fin}>>=
  for _, marker := range markers {
	  l := marker.End - marker.Start
	  if l >= *optM {
		  fmt.Printf("%s\t%d\t%d\n", marker.Chr,
			  marker.Start, marker.End)
	  }
  }
#+end_src
#+begin_export latex
We've finished \ty{findMacs}, time to test it.
\section*{Testing}
The outline for testing \ty{findMacs} has hooks for imports and the
testing logic.
#+end_export
#+begin_src go <<findMacs_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Pr. \ref{pr:fin}>>
  )

  func TestFindMacs(t *testing.T) {
	  //<<Testing, Pr. \ref{pr:fin}>>
  }
#+end_src
#+begin_export latex
We construct a set of tests, iterate over them, and run each one.
#+end_export
#+begin_src go <<Testing, Pr. \ref{pr:fin}>>=
  var tests []*exec.Cmd
  //<<Construct tests, Pr. \ref[pr:fin}>>
  for i, test := range tests {
	  //<<Run test, Pr. \ref{pr:fin}>>
  }
#+end_src
#+begin_export latex
We import \ty{exec}.
#+end_export
#+begin_src go <<Testing imports, Pr. \ref{pr:fin}>>=
  "os/exec"
#+end_src
#+begin_export latex
We construct two tests, one with only default parameters, the other
with the minimum marker length changed.
#+end_export
#+begin_src go <<Construct tests, Pr. \ref[pr:fin}>>=
  tar := "targets"
  nei := "neighbors"
  test := exec.Command("./findMacs", "-t", tar, "-n", nei)
  tests = append(tests, test)
  test = exec.Command("./findMacs", "-t", tar, "-n", nei, "-m", "200")
  tests = append(tests, test)
#+end_src
#+begin_export latex
We run the test and compare the output we get to the output we want,
which is contained in files \ty{r1.txt} and \ty{r2.txt}.
#+end_export
#+begin_src go <<Run test, Pr. \ref{pr:fin}>>=
  get, err := test.Output()
  if err != nil {
	  t.Error(err)
  }
  fn := "r" + strconv.Itoa(i+1) + ".txt"
  want, err := os.ReadFile(fn)
  if !bytes.Equal(get, want) {
	  t.Errorf("want:\n%s\nget:\n%s\n", want, get)
  }
#+end_src
#+begin_export latex
We import \ty{strconv}, \ty{os}, and \ty{bytes}.
#+end_export
#+begin_src go <<Testing imports, Pr. \ref{pr:fin}>>=
  "strconv"
  "os"
  "bytes"
#+end_src


