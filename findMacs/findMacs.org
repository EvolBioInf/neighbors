#+begin_export latex
\section{\ty{findMacs}}
The program \ty{findMacs} is a shell script for finding marker
candidates for a set of target genomes. It takes as input a directory
of target genomes and a directory of neighbor genomes and returns the
regions common to the targets that are absent from the neighbors. This
is similar to what \ty{fur} does~\cite{hau21:fur}, but \ty{findMacs}
is based on a combination of \ty{nucmer}~\cite{mrc18:mum} or
\ty{mapmash}~\cite{jai18:fas} for aligning genomes, and
\ty{bedtools}~\cite{qui10:bed} for manipulating sets of
intervals. Using these tools, \ty{findMacs} performs the following
steps:
\begin{itemize}
\item Identify arbitrary target as target representative, $r$.
\item Subtract neighbors $N$ from $r$ to get the first set of marker
  candidates,
  \[
  M_1 = r - N.
  \]
\item Intersect the targets $t_1,t_2,...,t_n$ with $M_1$ to get the
  second and final set of marker candidates, $M_2$,
  \[
  M_2 = M_1\cap t_1\cap t_2\cap...\cap t_n.
  \]
\end{itemize}

Intervals in \ty{nucmer}, \ty{mapmash}, and \ty{bedtools} have
zero-based starting points and one-based end points, that is, they are
half-open to the left. For example, the BED interval $(2,5]$ covers
  the nucleotides $[3,5]$. In contrast, \ty{findMacs} returns
  one-based start and end points. The coordinates we use throughout
  these calculations are with respect to the target representative.

\section*{Implementation}
We declare \ty{findMacs} a bash script. Then we interact with the
user, determine the target representative, subtract the neighbors,
intersect the targets, and print the results. Throughout, we generate
intermediary results that we store in various files. So at the end we
delete these files again.  \bpr{findMacs}{pr:fin}
#+end_export
#+begin_src sh <<findMacs.sh>>=
  #!/usr/bin/env bash
  //<<Interact with user, Pr. \ref{pr:fin}>>
  //<<Determine target representative, Pr. \ref{pr:fin}>>
  //<<Subtract neighbors, Pr. \ref{pr:fin}>>
  //<<Intersect targets, Pr. \ref{pr:fin}>>
  //<<Print results, Pr. \ref{pr:fin}>>
  //<<Delete intermediary files, Pr. \ref{pr:fin}>>
#+end_src
#+begin_export latex
\epr For interacting with the user, we construct a help message, parse
the options, and ensure the user provided target and neighbor
directories.
#+end_export
#+begin_src sh <<Interact with user, Pr. \ref{pr:fin}>>=
  //<<Construct help message, Pr. \ref{pr:fin}>>
  //<<Parse options, Pr. \ref{pr:fin}>>
  //<<Ensure directories, Pr. \ref{pr:fin}>>
#+end_src
#+begin_export latex
The help message consists of a usage, an explanation of the purpose of
\ty{findMacs}, and an example command. This is followed by an
explanation of the two options we define, help (\ty{-h}) and
\ty{nucmer} instead of \ty{mashmap} (\ty{-n}).
#+end_export
#+begin_src sh <<Construct help message, Pr. \ref{pr:fin}>>=
  msg="Usage: findMacs [options] <targetsDir> <neighborsDir>"
  msg="$msg\nFind marker candidates present in all targets "
  msg="$msg and absent from all neighbors."
  msg="$msg\nExample: findMacs targets/ neighbors/"
  msg="$msg\nOptions:\n\t-n use nucmer (default mashmap)"
  msg="$msg\n\t-h print this message and exit"
#+end_src
#+begin_export latex
If the user asked for help, we print the help message and exit. If the
user asked for \ty{nucmer}, we set the variable \ty{nOpt} to 1,
otherwise it's 0.
#+end_export
#+begin_src sh <<Parse options, Pr. \ref{pr:fin}>>=
  nOpt=0
  while getopts nh o
  do
      case $o in
	  n) nOpt=1;;
	  h) echo -e $msg; exit 0;;
      esac
  done
#+end_src
#+begin_export latex
If after \ty{getopts} there are not exactly two parameters, we print a
message asking for target and neighbor directories, and
exit. Otherwise we save the target and neighbor directories.
#+end_export
#+begin_src sh <<Ensure directories, Pr. \ref{pr:fin}>>=
  shift $(( OPTIND - 1 ))
  if [[ $1 = "" || $2 = "" ]]
  then
      printf "Usage: findMacs targetDir neighborDir\n"
      exit 0
  fi
  td=$1
  nd=$2
#+end_src
#+begin_export latex
Any target sequence can serve as representative, so we take the first
one.
#+end_export
#+begin_src sh <<Determine target representative, Pr. \ref{pr:fin}>>=
  r=$(ls $td/*.fasta | head -n 1)
#+end_src
#+begin_export latex
To subtract the neighbors, we compare the target representative to the
neighbors. Then we extract the target intervals and the neighbor hits
on those intervals, before we subtract the neighbor hits from the
target intervals.
#+end_export
#+begin_src sh <<Subtract neighbors, Pr. \ref{pr:fin}>>=
  //<<Compare target representative to neighbors, Pr. \ref{pr:fin}>>
  //<<Extract target intervals, Pr. \ref{pr:fin}>>
  //<<Extract neighbor hits, Pr. \ref{pr:fin}>>
  //<<Subtract neighbor hits from target intervals, Pr. \ref{pr:fin}>>
#+end_src
#+begin_export latex
We compare the target representative to the neighbors either with
\ty{nucmer} or with \ty{mashmap}. Both programs take as input a
reference and a query sequence file. The reference is the target
representative. For the query we store all neighbors in a file that we
generate with \ty{mktemp} to ensure it is unique. As output we require
from either program a file in PAF format, for which we also generate a
unique name.
#+end_export
#+begin_src sh <<Compare target representative to neighbors, Pr. \ref{pr:fin}>>=
  query=$(mktemp $nd/queryXXX)
  cat $nd/*.fasta > $query
  paf=$(mktemp $td/pafXXX)
  if [[ $nOpt -eq 1 ]]
  then
      //<<Compare to neighbors with \ty{nucmer}, Pr. \ref{pr:fin}>>
  else
      //<<Compare to neighbors with \ty{mashmap}, Pr. \ref{pr:fin}>>
  fi
#+end_src
#+begin_export latex
The immediate output of \ty{nucmer} is a unique delta file, which we
convert to PAF using \ty{paftools.js} from the \ty{minimap2}
package\footnote{https://github.com/lh3/minimap2}.
#+end_export
#+begin_src sh <<Compare to neighbors with \ty{nucmer}, Pr. \ref{pr:fin}>>=
  delta=$(mktemp $td/deltaXXX)
  nucmer --delta=$delta $r $query
  paftools.js delta2paf $delta > $paf
#+end_src
#+begin_export latex
The program \ty{mashmap} expects an indexed query, which we provide
with \ty{samtools}~\cite{li09:fas}. Then run \ty{mashmap} with the
shortest segment length possible, 100. This means the smallest
alignment we can detect are 200 bp long.
#+end_export
#+begin_src sh <<Compare to neighbors with \ty{mashmap}, Pr. \ref{pr:fin}>>=
  samtools faidx $query
  mashmap -s 100 -q $query -r $r -o $paf
#+end_src
#+begin_export latex
For the actual subtraction $a-b$, we create a unique file $a$, which
contains the intervals $(0,l_i]$, where $l_i$ is the length of the
  $i$-th sequence making up the target representative.
#+end_export
#+begin_src sh <<Extract target intervals, Pr. \ref{pr:fin}>>=
  a=$(mktemp $td/aXXX.bed)
  cut -f 6,7 $paf |
      sort |
      uniq |
      awk '{printf "%s\t0\t%d\n", $1, $2}' > $a
#+end_src
#+begin_export latex
The file $b$ in our subtraction contains the neighbor hits, which we
extract from the PAF file.
#+end_export
#+begin_src sh <<Extract neighbor hits, Pr. \ref{pr:fin}>>=
  b=$(mktemp $td/bXXX.bed)
  awk '{printf "%s\t%d\t%d\n", $6, $8, $9}' $paf > $b
#+end_src
#+begin_export latex
We carry out the subtraction with \ty{bedtools} and save the output in
file $m_1$.
#+end_export
#+begin_src sh <<Subtract neighbor hits from target intervals, Pr. \ref{pr:fin}>>=
  m1=$(mktemp $td/m1XXX.bed)
  bedtools subtract -a $a -b $b > $m1
#+end_src
#+begin_export latex
Now we intersect the remaining targets with the target
representative. For this we determine the list of targets excluding
the representative. Then we iterate over that list and intersect each
target with the representative. The trick is to store for each
sequence comparison the complement. Complementation requires a
``genome'' file containing the lengths of the sequences that make up
the target representative. We store the combined complements in file
$c$ and subtract them at the end from $M_1$ to get out final set of
marker intervals, $M_2$.
#+end_export
#+begin_src sh <<Intersect targets, Pr. \ref{pr:fin}>>=
  targets=$(ls $td/*.fasta | tail -n +2)
  c=$(mktemp $td/cXXX.bed)
  t=$(mktemp $td/tXXX.bed)
  //<<Create genome file, Pr. \ref{pr:fin}>>
  for target in $targets
  do
      //<<Intersect one target, Pr. \ref{pr:fin}>>
  done
  m2=$(mktemp $td/m2XXX.bed)
  bedtools subtract -a $m1 -b $c > $m2
#+end_src
#+begin_export latex
We create a unique name for the genome file and extract the sequence
lengths.
#+end_export
#+begin_src sh <<Create genome file, Pr. \ref{pr:fin}>>=
  g=$(mktemp $td/gXXX.bed)
  cut -f 6,7 $paf |
      sort |
      uniq > $g
#+end_src
#+begin_export latex
To intersect the current target, we compare it to the target
representative and extract the target hits, which we then complement.
#+end_export
#+begin_src sh <<Intersect one target, Pr. \ref{pr:fin}>>=
  //<<Compare target to representative, Pr. \ref{pr:fin}>>
  //<<Extract target hits, Pr. \ref{pr:fin}>>
  //<<Complement target hits, Pr. \ref{pr:fin}>>
#+end_src
#+begin_export latex
We compare the target to the representative again using either
\ty{nucmer} or \ty{mashmap}.
#+end_export
#+begin_src sh <<Compare target to representative, Pr. \ref{pr:fin}>>=
  if [[ $nOpt -eq 1 ]]
  then
      //<<Compare rep with \ty{nucmer}, Pr. \ref{pr:fin}>>
  else
      //<<Compare rep with \ty{mashmap}, Pr. \ref{pr:fin}>>
  fi
#+end_src
#+begin_export latex
We run \ty{nucmer} as we did in the subtraction step.
#+end_export
#+begin_src sh <<Compare rep with \ty{nucmer}, Pr. \ref{pr:fin}>>=
  nucmer --delta=$delta $r $target
  paftools.js delta2paf $delta > $paf
#+end_src
#+begin_export latex
The index files for the \ty{mashmap} queries might already have been
generated in a previous round of analysis or by another process
working on the same data. Hence we check for their existence and
generate them only if necessary.
#+end_export
#+begin_src sh <<Compare rep with \ty{mashmap}, Pr. \ref{pr:fin}>>=
  if [[ ! -f ${target}.fai ]]
  then
      samtools faidx $target
  fi
  mashmap -s 100 -r $r -q $target -o $paf
#+end_src
#+begin_export latex
We extract the target hits from the PAF file and sort
them.
#+end_export
#+begin_src sh <<Extract target hits, Pr. \ref{pr:fin}>>=
  awk '{printf "%s\t%d\t%d\n", $6, $8, $9}' $paf |
      sort -k 2 -n > $t
#+end_src
#+begin_export latex
We take the complement of the result and accumulate it in
\ty{c.bed}. To keep this file tidy, we merge the intervals after
adding new ones. Both merging and complementing require sorted input.
#+end_export
#+begin_src sh <<Complement target hits, Pr. \ref{pr:fin}>>=
  bedtools complement -i $t -g $g >> $c
  tmp=$(mktemp $td/tmpXXX.bed)
  sort -k 2 -n $c > $tmp
  mv $tmp $c
  bedtools merge -i $c > $tmp
  mv $tmp $c
#+end_src
#+begin_export latex
As the final result, we print the intervals in $M_2$ that are at least
100 bp long. We change the half-open intervals of \ty{bedtools} and
\ty{mashmap} to closed.
#+end_export
#+begin_src sh <<Print results, Pr. \ref{pr:fin}>>=
  awk '{
      l = $3 - $2
      if (l >= 100)
	 printf "%s\t%d\t%d\n", $1, $2+1, $3
      }' $m2
#+end_src
#+begin_export latex
At the end of \ty{findMacs} we delete the various intermediary files
we generated.
#+end_export
#+begin_src sh <<Delete intermediary files, Pr. \ref{pr:fin}>>=
  rm $query $paf $a $b $m1 $c $g $m2 $t
  if [[ $nOpt -eq 1 ]]
  then
      rm $delta
  else
      rm ${query}.fai
  fi
#+end_src
