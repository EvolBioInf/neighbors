Diagnostic PCR-markers are designed to amplify all members of a target
set of organisms and nothing else. A promising approach to ensure
marker specificity is to compare the target genomes to the genomes of
the closest distinct relatives, the neighbors. Any target region that
distinguishes it from the neighbors stands a good chance of being
unique across the board. The program \ty{fur} implements this idea,
and markers constructed from its output have excellent specificity and
sensifivity~\cite{hau21:fur}.

To use \ty{fur}, users need to know the neighbors of their
targets. But how can neighbors be discovered, if they aren't already
known? To answer this question, consider the toy taxonomy in
Figure~\ref{fig:tax}, where the numbers are taxon-IDs. We also assume
that we have a mapping from taxon-IDs to genome accessions. Let taxa 7
and 4 be our targets. Then we look up the most recent common ancestor
of 4 and 7, which is 3. This would imply that 6 also belongs to the
target set. The neighbors are the nodes in the subtree rooted on 3's
parent, that is, the five taxa 2, 8, 9, 10, and 11. Notice that we
look up all nodes in a subtree minus its root, not just the leaves, as
we cannot assume that genome sequences are only associated with taxa
in terminal nodes.

\begin{figure}
\begin{center}
\input{tree}
\end{center}
\caption{Toy taxonomy.}\label{fig:tax}
\end{figure}

To put this a bit more formally, let $m$ be the most recent common
ancestor of the targets. Their neighbors, $\mathcal{N}$, are then
computed by subtracting the nodes in $m$'s subtree from the nodes in
its parent's subtree
\begin{equation}\label{eq:nei}
\mathcal{N} = s(p(m)) - s(m),
\end{equation}
where $s(v)$ returns the nodes in the subtree rooted on $v$, and
$p(v)$ the parent of $v$. This set subtraction is implemented in the
program \ty{neighbors}.

\ty{neighbors} is centered on an \ty{sqlite}
database that combines taxonomy and genome information. The database
is built using the program \ty{makeNeiDb}, which is based on the
packages \ty{tdb}, \ty{tax}, and \ty{util}, also part of the module.

Let's call the central database \ty{taxonomyDb}; as shown in
Figure~\ref{fig:db}, \ty{taxonomyDb} consists of two
tables, \ty{genome} and \ty{taxon}. Each genome comes from an organism
identified by its taxon-ID, has a size, and one or more replicons,
which are lumped in one attribute. Each genome belongs to a taxon. A
taxon has a taxon-ID, a parent, and a name. Several genomes may have
been sequenced for a given taxon. This means that the
attribute \ty{taxid} in table \ty{genome} is not unique and we don't
declare an explicit primary key on that table.

\begin{figure}
  \begin{center}
    \input{db}
  \end{center}
  \caption{Diagram of \ty{taxonomyDb}.}\label{fig:db}
\end{figure}

Once the database is constructed, we can query it. For example, we
can list the taxon-IDs associated with \emph{Aerococcus urinae}.
\begin{verbatim}
$ sqlite taxonomyDb \
  "select taxid, name from genome where name like 'Aerococcus urinae%'"
\end{verbatim}
Next, the program \ty{dree} can draw the taxonomic tree rooted on a
taxon. Finally, we can submit the taxa of interes to \ty{neighbors},
which finds their closest neighbors and the associates genome
sequences. The Tutorial shows how the
programs \ty{makeNeiDb}, \ty{dree}, and \ty{neighbors} can be used to
discover diagnostic regions.
