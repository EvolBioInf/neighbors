Diagnostic PCR-markers are designed to amplify all members of a target
set of organisms and nothing else. A promising approach to ensure
marker specificity is to compare the target genomes to the genomes of
the closest distinct relatives, the neighbors. This usually removes
the vast majority of non-specific material. The small remainder can
then be further tested by \emph{in silico} PCR against, say, the
non-redundant collection of nucleotide sequences, \ty{nt}. The
published program \ty{fur} implements this comparison between targets
and neighbors. Markers constructed from its output can have excellent
specificity and sensifivity~\cite{hau21:fur}.

Users of programs like \ty{fur} need to know the neighbors of their
targets. But how can neighbors be discovered, if they aren't already
known? To answer this question, consider the toy taxonomy in
Figure~\ref{fig:tax}, where the numbers are taxon-IDs that are linked
to genome accessions. Let taxa 7 and 4 be our targets. Their most
recent common ancestor is 3. This implies there are three additional
targets, 3, 5, and 6. The neighbors are the nodes in the subtree
rooted on 3's parent, minus the parent and minus the targets. So in
our example there are five neighbors, 2, 8, 9, 10, and 11. Notice that
we look up all nodes in a subtree, not just the leaves, as genome
sequences might be associated with taxa in terminal and internal
nodes.

\begin{figure}
\begin{center}
\input{tree}
\end{center}
\caption{Toy taxonomy.}\label{fig:tax}
\end{figure}

To put this a bit more formally, let $m$ be the most recent common
ancestor of the targets. Their neighbors, $\mathcal{N}$, are then
computed by subtracting the nodes in $m$'s subtree from the nodes in
its parent's subtree, minus the parent
\begin{equation}\label{eq:nei}
\mathcal{N} = s(p(m)) - s(m) - p(m),
\end{equation}
where $s(v)$ returns the nodes in the subtree rooted on $v$, and
$p(v)$ the parent of $v$. This set subtraction is implemented in the
program \ty{neighbors}.

The Neighbors package consists of the nine programs listed in
Table~\ref{tab:pro} and is centered on an \ty{sqlite3} database that
combines taxonomy and genome information. 
\begin{table}
\caption{The nine programs of Neighbors}\label{tab:pro}
\begin{center}
\begin{tabular}{lll}
\hline
\# & Name & Function\\\hline
1 & \ty{ants} & list the ancestors of a taxon\\
2 & \ty{dree} & draw taxonomic tree rooted on taxid\\
3 & \ty{fintac} & find target clade\\
4 & \ty{land} & label nodes in Newick tree\\
5 & \ty{makeNeiDb} & construct taxonomy and genomes database\\
6 & \ty{neighbors} & complete targets and list neighbors\\
7 & \ty{outliers} & find outliers in a set of numerical data\\
8 & \ty{pickle} & pick clades in a Newick tree\\
9 & \ty{taxi} & get taxon-ID from taxon name\\\hline
\end{tabular}
\end{center}
\end{table}

The database, let's call it \ty{neidb}, is built using the
program \ty{makeNeiDb}. As shown in Figure~\ref{fig:db}, \ty{neidb}
consists of two tables, \ty{genome} and \ty{taxon}. Each genome comes
from an organism identified by its taxon-ID, has a size, a status, a
genome accession, and one or more replicons, which are lumped in one
attribute. Each genome belongs to a taxon. A taxon has a unique
taxon-ID, which serves as primary key. A taxon also has a parent, a
rank, and a name. Since several genomes may have been sequenced for a
given taxon, the attribute \ty{taxid} in table \ty{genome} is not
unique, which is why that table has no primary key.

\begin{figure}
  \begin{center}
    \input{db}
  \end{center}
  \caption{Diagram of \ty{neidb}.}\label{fig:db}
\end{figure}

Once the database is constructed, we can query it. The tutorial shows
how to do for \emph{E. coli} O157:H7. It is a notorious food-borne
pathogen that can cause severe diarrhea in humans. The
program \ty{taxi} gives us the taxon-ID for \emph{E. coli} O157:H7. It
is often useful to place this taxon-ID into context, for which we have
two programs, \ty{dree} and \ty{andi}. Starting from a
taxon-ID, \ty{dree} draws the taxonomic tree rooted on that
taxon-ID. Instead of walking from a root towards the leaves, the
program \ty{ants} starts from a taxon and walks in the opposite
direction toward the universal root. Along this path, \ty{ants} lists
all ancestral taxa of our focal taxon. Once we've got our bearings in
the taxonomy, we can query it with \ty{neighbors} to get the complete
set of target and neighbor genomes currently available.

The genomes returned by \ty{neighbors} form the raw material for
marker discovery. However, the classification into targets and
neighbors retrieved from the taxonomy often contradicts the phylogeny
calculated from the target and neighbor genomes. So we should always
compute a phylogeny from our target and neighbor genomes. A program
for doing this efficiently is \ty{phylonium}~\cite{klo20:phy}.

The phylogenies of targets and neighbors may comprise hundreds of
taxa. Neighbors contains three programs to help analyze such large
phylogenies, \ty{land} for labeling nodes, \ty{pickle} for picking
nodes, and \ty{fintac} for finding the target clade.

Even a clean set of phylogenetic targets might still contain genomes
that are outliers in some way, for example with respect to their
genome lengths. The program \ty{outliers} helps find such
outliers. The tutorial contains the details.
