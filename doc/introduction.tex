Diagnostic PCR-markers are designed to amplify all members of a target
set of organisms and nothing else. A promising approach to ensure
marker specificity is to compare the target genomes to the genomes of
the closest distinct relatives, the neighbors. This removes the vast
majority of non-specific material. The small remainder can then be
further tested by \emph{in silico} PCR against, say the non-redundant
collection of nucleotide sequences, \ty{nt}. The program \ty{fur}
implements this comparison between targets and neighbors, and markers
constructed from its output have excellent specificity and
sensifivity~\cite{hau21:fur}.

Users of \ty{fur} need to know the neighbors of their targets. But how
can neighbors be discovered, if they aren't already known? To answer
this question, consider the toy taxonomy in Figure~\ref{fig:tax},
where the numbers are taxon-IDs that are linked to genome
accessions. Let taxa 7 and 4 be our targets. Then we look up the most
recent common ancestor of 4 and 7, which is 3. This implies there are
five targets, 3, 4, 5, 6, and 7. The neighbors are the nodes in the
subtree rooted on 3's parent, minus the parent and minus the
targets. So in our example there are five neighbors, 2, 8, 9, 10, and
11. Notice that we look up all nodes in a subtree, not just the
leaves, as genome sequences might be associated with taxa in terminal
and internal nodes.

\begin{figure}
\begin{center}
\input{tree}
\end{center}
\caption{Toy taxonomy.}\label{fig:tax}
\end{figure}

To put this a bit more formally, let $m$ be the most recent common
ancestor of the targets. Their neighbors, $\mathcal{N}$, are then
computed by subtracting the nodes in $m$'s subtree from the nodes in
its parent's subtree, minus the parent
\begin{equation}\label{eq:nei}
\mathcal{N} = s(p(m)) - s(m) - p(m),
\end{equation}
where $s(v)$ returns the nodes in the subtree rooted on $v$, and
$p(v)$ the parent of $v$. This set subtraction is implemented in the
program \ty{neighbors}.

\ty{neighbors} is centered on an \ty{sqlite3}
database that combines taxonomy and genome information. The database
is built using the program \ty{makeNeiDb}, which is based on the
packages \ty{tdb}, \ty{tax}, and \ty{util} contained in the
\ty{neighbors} module.

Let's call the central database \ty{neidb}; as shown in
Figure~\ref{fig:db}, \ty{neidb} consists of two
tables, \ty{genome} and \ty{taxon}. Each genome comes from an organism
identified by its taxon-ID, has a size, and one or more replicons,
which are lumped in one attribute. Each genome belongs to a taxon. A
taxon has a unique taxon-ID, which serves as primary key. A taxon also
has a parent and a name. Since several genomes may have been sequenced for a
given taxon, the attribute \ty{taxid} in
table \ty{genome} is not unique, which is why that table has no
primary key.

\begin{figure}
  \begin{center}
    \input{db}
  \end{center}
  \caption{Diagram of \ty{neidb}.}\label{fig:db}
\end{figure}

Once the database is constructed, we can query it. A typical sequence
of queries would start from the target organism of interest,
say \emph{Aerococcus urinae}. The first thing we'd need is its
taxon-ID. We get this using the program \ty{taxi}, which is also part
of \ty{neighbors}.
\begin{verbatim}
$ taxi -s "Aerococcus urinae" neidb
\end{verbatim}
Next, the program \ty{dree} can draw the taxonomic tree rooted on a
taxofn.In other words, the program \ty{dree} walks from a taxon to the
leaves of the subtree rooted on the taxon. In contrast, the
program \ty{ants} lets us walk in the opposite direction, from a taxon
to its ancestors. These two programs, \ty{dree} and \ty{ants}, help us
explore the context of a taxon. Finally, we can submit the taxa of
interest to \ty{neighbors}, which finds their closest neighbors and
the associated genome sequences.

The genome sequences of targets and neighbors are best analyzed
further by converting them into a phylogeny. Such phylogenies are
often large and need to be broken down into individual clades. We can
pick individual clades from a Newick tree by first labeling the
internal nodes with \ty{land} and then picking clades
with \ty{pickle}. The Tutorial shows how the seven
programs \ty{makeNeiDb}, \ty{taxi}, \ty{dree}, \ty{ants},
\ty{neighbors}, \ty{land}, and \ty{pickle} can be used to discover
diagnostic regions from bacterial genomes.
