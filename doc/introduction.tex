Diagnostic PCR-markers are designed to amplify all members of a target
set of organisms and nothing else. A promising approach to ensure
marker specificity is to compare the target genomes to the genomes of
the closest distinct relatives, the neighbors. This usually removes
the vast majority of non-specific material. The small remainder can
then be further tested by \emph{in silico} PCR against, say, the
non-redundant collection of nucleotide sequences, \ty{nt}. The
published program \ty{fur} implements this comparison between targets
and neighbors. Markers constructed from its output have excellent
specificity and sensifivity~\cite{hau21:fur}.

Users of programs like \ty{fur} need to know the neighbors of their
targets. But how can neighbors be discovered, if they aren't already
known? To answer this question, consider the toy taxonomy in
Figure~\ref{fig:tax}, where the numbers are taxon-IDs that are linked
to genome accessions. Let taxa 7 and 4 be our targets. Their most
recent common ancestor is 3. This implies there are three additional
targets, 3, 5, and 6. The neighbors are the nodes in the subtree
rooted on 3's parent, minus the parent and minus the targets. So in
our example there are five neighbors, 2, 8, 9, 10, and 11. Notice that
we look up all nodes in a subtree, not just the leaves, as genome
sequences might be associated with taxa in terminal and internal
nodes.

\begin{figure}
\begin{center}
\input{tree}
\end{center}
\caption{Toy taxonomy.}\label{fig:tax}
\end{figure}

To put this a bit more formally, let $m$ be the most recent common
ancestor of the targets. Their neighbors, $\mathcal{N}$, are then
computed by subtracting the nodes in $m$'s subtree from the nodes in
its parent's subtree, minus the parent
\begin{equation}\label{eq:nei}
\mathcal{N} = s(p(m)) - s(m) - p(m),
\end{equation}
where $s(v)$ returns the nodes in the subtree rooted on $v$, and
$p(v)$ the parent of $v$. This set subtraction is implemented in the
program \ty{neighbors}.

The Neighbors package consists of the eight programs listed in
Table~\ref{tab:pro} and is centered on an \ty{sqlite3} database that
combines taxonomy and genome information. 
\begin{table}
\caption{The eight programs of Neighbors}\label{tab:pro}
\begin{center}
\begin{tabular}{lll}
\hline
\# & Name & Function\\\hline
1 & \ty{ants} & list the ancestors of a taxon\\
2 & \ty{dree} & draw taxonomic tree rooted on taxid\\
3 & \ty{land} & label nodes in Newick tree\\
4 & \ty{makeNeiDb} & construct taxonomy and genomes database\\
5 & \ty{neighbors} & complete targets and list neighbors\\
6 & \ty{outliers} & find outliers in a set of numerical data\\
7 & \ty{pickle} & pick clades in a Newick tree\\
8 & \ty{taxi} & get taxon-ID from taxon name\\\hline
\end{tabular}
\end{center}
\end{table}

The database, let's call it \ty{neidb}, is built using the
program \ty{makeNeiDb}. As shown in Figure~\ref{fig:db}, \ty{neidb}
consists of two tables, \ty{genome} and \ty{taxon}. Each genome comes
from an organism identified by its taxon-ID, has a size, a status, a
genome accession, and one or more replicons, which are lumped in one
attribute. Each genome belongs to a taxon. A taxon has a unique
taxon-ID, which serves as primary key. A taxon also has a parent, a
rank, and a name. Since several genomes may have been sequenced for a
given taxon, the attribute \ty{taxid} in table \ty{genome} is not
unique, which is why that table has no primary key.

\begin{figure}
  \begin{center}
    \input{db}
  \end{center}
  \caption{Diagram of \ty{neidb}.}\label{fig:db}
\end{figure}

Once the database is constructed, we can query it. The tutorial shows
how to do this. Our example organism is the pathogenic \emph{E. coli}
serotype O157:H7. It is a notorious food-borne pathogen that can cause
severe diarrhea in humans. The program \ty{taxi} gives us the taxon-ID
for \emph{E. coli} O157:H7. It is often useful to place this taxon-ID
into context, for which we have two programs, \ty{dree}
and \ty{andi}. Starting from a taxon-ID \ty{dree} draws the taxonomic
tree rooted on that taxon-ID. Instead of walking from a root towards
the leaves, the program \ty{ants} starts from a taxon and walks in the
opposite direction toward the universal root. Along this
path, \ty{ants} lists all ancestral taxa of our focal taxon. Once
we've got our bearings in the taxonomy, we can query it
with \ty{neighbors} to get the complete set of target and neighbor
genomes currently available.

The genome returned by \ty{neighbors} form the raw material for marker
discovery. However, the classification into targets and neighbors
retrieved from the taxonomy often contradicts the phylogeny calculated
from the target and neighbor genomes. So we should always compute a
phylogeny from our target and neighbor genomes. A program for doing
this efficiently is \ty{phylonium}~\cite{klo20:phy}.

The phylogenies of targets and neighbors may contain hundreds of
taxa. Neighbors contains two programs to help analyze such large
phylogenies, \ty{land} for labeling nodes, and \ty{pickle} for picking
nodes.






A typical sequence
of queries would start from the target organism of interest,
say \emph{Aerococcus urinae}. The first thing we'd need is its
taxon-ID. We get this using the program \ty{taxi}, which is also part
of \ty{neighbors}.
\begin{verbatim}
$ taxi -s "Aerococcus urinae" neidb
\end{verbatim}
Next, the program \ty{dree} can draw the taxonomic tree rooted on a
taxon, $r$. In other words, the program \ty{dree} walks from a taxon
to the leaves of the subtree rooted on the
taxon. Alternatively, \ty{dree} can also just list the taxa in the
subtree rooted on $r$. In contrast, the program \ty{ants} lets us walk
in the opposite direction, from a taxon to its ancestors. These two
programs, \ty{dree} and \ty{ants}, help us explore the context of a
taxon. Finally, we can submit the taxa of interest to \ty{neighbors},
which finds their closest neighbors and the associated genome
sequences.

There is no guarantee that the classification provided by the taxonomy
is identical to the phylogeny of the target and neighbor genomes. Such
mixing of targets and neighbors would make marker discovery
impossible. So we convert tartes and neighbors to phylogenies. Such
phylogenies are often large and need to be broken down into individual
clades. We can pick the leaves of individual clades from a Newick tree
by first labeling the internal nodes with \ty{land} and then picking
clades with \ty{pickle} (Table~\ref{tab:pro}).

The Tutorial shows how the eight
programs \ty{makeNeiDb}, \ty{taxi}, \ty{dree}, \ty{ants},
\ty{neighbors}, \ty{land}, \ty{outliers}, and \ty{pickle} can be used
to find marker candidates for \emph{Aerococcus urinae}.
