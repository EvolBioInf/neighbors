#+begin_export latex
\section{\ty{rad}}
The program \ty{stan} simulates target and neighbor sequences to test
programs for marker discovery with neighbors. The marker patterns
generated by \ty{stan} are set by the user and consist of a set of
deletions that affect all neighbor sequences equally. Such ``uniform''
markers are not very realistic. To achieve more life-like marker
patterns, we write a program for generating random deletions in a
sequence, \ty{rad}.

The program \ty{rad} takes as input one or more sequence files and
deletes a Poisson-distributed number of regions from each
sequence. The user can set the expected number of regions deleted. The
length of the deletions is drawn from a normal distribution, where the
user can set the mean and the standard deviation.

To implement \ty{rad}, we need a source of Poisson-distributed random
numbers and a source of normally distributed random numbers. We
generate a random Poisson-distributed number, $N$, for an expectation
$\mu$ by drawing uniformly distributed random numbers until their
product $u_1 u_2...u_m\le e^{-m}$. Then $N\leftarrow
m-1$~\cite[p.137]{knu98:ar2}.

For normally distributed numbers with mean $m$ and standard deviation
$s$ we take the library function for the standard normal distribution,
call it $\mbox{rnorm}()$, and calculate
\[
r\leftarrow rnorm()\times s + m.
\]

\section*{Implementation}
Our outline for \ty{rad} contains hooks for imports, functions, and
the logic of the main function.
\bpr{rad}{pr:rad}
#+end_export
#+begin_src go <<rad.go>>=
  package main

  import (
	  //<<Imports, Pr. \ref{pr:rad}>>
  )

  //<<Functions, Pr. \ref{pr:rad}>>
  func main() {
	  //<<Main function, Pr. \ref{pr:rad}>>
  }
#+end_src
#+begin_export latex
\epr In the main function we prepare the messages from the \ty{log}
package by setting the program name, set the usage, declare the
options, parse the options, and parse the input files.
#+end_export
#+begin_src go <<Main function, Pr. \ref{pr:rad}>>=
  clio.PrepLog("rad")
  //<<Set usage, Pr. \ref{pr:rad}>>
  //<<Declare options, Pr. \ref{pr:rad}>>
  //<<Parse options, Pr. \ref{pr:rad}>>
  //<<Parse input files, Pr. \ref{pr:rad}>>
#+end_src
#+begin_export latex
We import \ty{clio}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:rad}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_export latex
The usage consists of the actual usage message, an explanation of the
purpose of \ty{rad}, and an example command.
#+end_export
#+begin_src go <<Set usage, Pr. \ref{pr:rad}>>=
  u := "rad [option]... [foo.fasta]..."
  p := "Randomly delete regions from sequences."
  e := "rad seq.fasta"
  clio.Usage(u, p, e)
#+end_src
#+begin_export latex
We import \ty{clio}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:rad}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_export latex
Apart from the version, \ty{-v}, we declare an option for the mean
number of deletions, \ty{-n}, the mean length of a deletion, \ty{-l},
the standard deviation of the length of a deletion \ty{-d}, and the
seed for the random number generator, \ty{-s}.
#+end_export
#+begin_src go <<Declare options, Pr. \ref{pr:rad}>>=
  optV := flag.Bool("v", false, "version")
  optN := flag.Float64("n", 3.0, "mean number of deletions")
  optL := flag.Float64("l", 200.0, "mean length of deletion")
  optD := flag.Float64("d", 200.0, "standard deviation of " +
	  "length of deletion")
  optS := flag.Int64("s", 0, "seed for random number " +
	  "generator (default internal)")
#+end_src
#+begin_export latex
We import \ty{flag}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:rad}>>=
  "flag"
#+end_src
#+begin_export latex
We parse the options and respond to \ty{-v}, as this stops the
program. Then we seed the random number generator either with the seed
provided via \ty{-s} or with the current time.
#+end_export
#+begin_src go <<Parse options, Pr. \ref{pr:rad}>>=
  flag.Parse()
  if *optV {
	  util.PrintInfo("rad")
  }
  seed := *optS
  if seed == 0 {
	  seed = time.Now().UnixNano()
  }
  source := rand.NewSource(seed)
  ran := rand.New(source)
#+end_src
#+begin_export latex
We import \ty{util}, \ty{time}, and \ty{rand}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:rad}>>=
  "github.com/evolbioinf/neighbors/util"
  "time"
  "math/rand"
#+end_src
#+begin_export latex
The remaining tokens on the command line are interpreted as names of
input files. We iterate over them with the function \ty{scan}, which
takes as arguments the mean number of deletions and the mean and standard
deviation of the deletion length.
#+end_export
#+begin_src go <<Parse input files, Pr. \ref{pr:rad}>>=
  files := flag.Args()
  clio.ParseFiles(files, scan, *optN, *optL, *optD, ran)
#+end_src
#+begin_export latex
Inside \ty{scan} we retrieve the parameters, iterate over the
sequences in the current file, delete regions from each sequence, and
print the changed sequence to the standard output stream.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:rad}>>=
  func scan(r io.Reader, args ...interface{}) {
	  //<<Retrieve arguments, Pr. \ref{pr:rad}>>
	  sc := fasta.NewScanner(r)
	  for sc.ScanSequence() {
		  seq := sc.Sequence()
		  //<<Delete regions, Pr. \ref{pr:rad}>>
		  fmt.Println(seq)
	  }
  }
#+end_src
#+begin_export latex
We import \ty{io}, \ty{fasta}, and \ty{fmt}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:rad}>>=
  "io"
  "github.com/evolbioinf/fasta"
  "fmt"
#+end_src
#+begin_export latex
We retrieve the four arguments just passed by type assertion.
#+end_export
#+begin_src go <<Retrieve arguments, Pr. \ref{pr:rad}>>=
  optN := args[0].(float64)
  optL := args[1].(float64)
  optD := args[2].(float64)
  ran := args[3].(*rand.Rand)
#+end_src
#+begin_export latex
We allocate a boolean array to mark the deleted nucleotides. Then we
pick the number of regions by calling the new function \ty{rpoi}. For
each region we pick the length of the deletion and its position,
before we mark the deletion. After looping over the deletion regions,
we remove the deleted nucleotides.
#+end_export
#+begin_src go <<Delete regions, Pr. \ref{pr:rad}>>=
  seqLen := len(seq.Data())
  deleted := make([]bool, seqLen)
  nDel := rpoi(optN, ran)
  for i := 0; i < nDel; i++ {
	  delLen := int(math.Round(ran.NormFloat64() *
		  optD + float64(optL)))
	  //<<Pick position of deletion, Pr. \ref{pr:rad}>>
	  //<<Mark deletion, Pr. \ref{pr:rad}>>
  }
  //<<Remove deleted nucleotides, Pr. \ref{pr:rad}>>
#+end_src
#+begin_export latex
We import \ty{math}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:rad}>>=
  "math"
#+end_src
#+begin_export latex
In the function \ty{rpoi} we implement the algorithm for picking a
Poisson-distributed random variable that is taken
from~\cite[p. 137]{knu98:ar2} and is described in the Introduction.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:rad}>>=
  func rpoi(m float64, ran *rand.Rand) int {
	  x := math.Exp(-m)
	  pr := 1.0
	  N := 0
	  for pr > x {
		  pr *= ran.Float64()
		  N++
	  }
	  return N - 1
  }
#+end_src
#+begin_export latex
We pick a random midpoint along the sequence for the deletion and then
convert this into a start and an end. We make sure that start and end
lie inside the sequence.
#+end_export
#+begin_src go <<Pick position of deletion, Pr. \ref{pr:rad}>>=
  mid := ran.Intn(seqLen)
  start := mid - delLen / 2
  end := start + delLen - 1
  if start < 0 {
	  start = 0
  }
  if end >= seqLen {
	  end = seqLen - 1
  }
#+end_src
#+begin_export latex
We mark the deleted positions.
#+end_export
#+begin_src go <<Mark deletion, Pr. \ref{pr:rad}>>=
  for i := start; i <= end; i++ {
	  deleted[i] = true
  }
#+end_src
#+begin_export latex
We create a new sequence without the deleted nucleotides.
#+end_export
#+begin_src go <<Remove deleted nucleotides, Pr. \ref{pr:rad}>>=
  d1 := seq.Data()
  d2 := make([]byte, 0, len(d1))
  for i, c := range d1 {
	  if !deleted[i] {
		  d2 = append(d2, c)
	  }
  }
  seq = fasta.NewSequence(seq.Header(), d2)
#+end_src
#+begin_export latex
We've finished writing \ty{rad}, so let's test it.

\section*{Testing}
The outline of our code for testing \ty{rad} contains hooks for
imports and the testing logic.
#+end_export
#+begin_src go <<rad_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Pr. \ref{pr:rad}>>
  )

  func TestRad(t *testing.T) {
	  //<<Testing, Pr. \ref{pr:rad}>>
  }
#+end_src
#+begin_export latex
We construct a number of tests and run each one.
#+end_export
#+begin_src go <<Testing, Pr. \ref{pr:rad}>>=
  var tests []*exec.Cmd
  //<<Construct tests, Pr. \ref{pr:rad}>>
  for i, test := range tests {
	  //<<Run test, Pr. \ref{pr:rad}>>
  }
#+end_src
#+begin_export latex
We import \ty{exec}.
#+end_export
#+begin_src go <<Testing imports, Pr. \ref{pr:rad}>>=
  "os/exec"
#+end_src
#+begin_export latex
We first construct a test with only default options. Then we construct
three more tests to try out the three options mean deletion length,
\ty{-l}, standard deviation of deletion length, \ty{-d}, and mean
number of deletions, \ty{-n}. In each of the four tests we set the
seed of the random number generator to make the test reproducible.
#+end_export
#+begin_src go <<Construct tests, Pr. \ref{pr:rad}>>=
  f := "test.fasta"
  test := exec.Command("./rad", "-s", "3", f)
  tests = append(tests, test)
  test = exec.Command("./rad", "-s", "3", "-l", "100", f)
  tests = append(tests, test)
  test = exec.Command("./rad", "-s", "3", "-d", "100", f)
  tests = append(tests, test)
  test = exec.Command("./rad", "-s", "3", "-n", "1", f)
  tests = append(tests, test)
#+end_src
#+begin_export latex
For a given test we compare the result we get with the result we want,
which is contained in files \ty{r1.fasta}, \ty{r2.fasta}, and so on.
#+end_export
#+begin_src go <<Run test, Pr. \ref{pr:rad}>>=
  get, err := test.Output()
  if err != nil {
	  t.Error(err)
  }
  fn := "r" + strconv.Itoa(i + 1) + ".fasta"
  want, err := os.ReadFile(fn)
  if err != nil {
	  t.Error(err)
  }
  if !bytes.Equal(get, want) {
	  t.Errorf("get:\n%s\nwant:\n%s\n", get, want)
  }
#+end_src
#+begin_export latex
We import \ty{strconv}, \ty{os}, and \ty{bytes}.
#+end_export
#+begin_src go <<Testing imports, Pr. \ref{pr:rad}>>=
  "strconv"
  "os"
  "bytes"
#+end_src

